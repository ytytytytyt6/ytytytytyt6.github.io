<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/ytytytytyt6.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/ytytytytyt6.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/ytytytytyt6.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/ytytytytyt6.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/ytytytytyt6.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/ytytytytyt6.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/ytytytytyt6.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="进一寸有一寸的欢喜">
<meta property="og:type" content="website">
<meta property="og:title" content="思睿&#39;s Blog">
<meta property="og:url" content="https://ytytytytyt6.github.io/index.html">
<meta property="og:site_name" content="思睿&#39;s Blog">
<meta property="og:description" content="进一寸有一寸的欢喜">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="万俟思睿">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/ytytytytyt6.github.io/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ytytytytyt6.github.io/"/>





  <title>思睿's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/ytytytytyt6.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思睿's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/ytytytytyt6.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E6%A3%80%E6%9F%A5Trickbot%E6%84%9F%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E6%A3%80%E6%9F%A5Trickbot%E6%84%9F%E6%9F%93/" itemprop="url">Wireshark教程：检查Trickbot感染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-03T20:17:30+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="检查Trickbot感染"><a href="#检查Trickbot感染" class="headerlink" title="检查Trickbot感染"></a>检查Trickbot感染</h1><p>当主机被感染或以其他方式受到威胁时，有权访问网络流量的数据包捕获（pcap）的安全专业人员需要了解活动并确定感染的类型。</p>
<p>本教程提供了有关如何识别Trickbot的提示，Trickbot是自2016年以来一直感染受害者的信息窃取者和银行恶意软件。Trickbot通过恶意垃圾邮件（malspam）分发，并且还由其他恶意软件（例如Emotet，IcedID或Ursnif）分发。</p>
<p>Trickbot具有独特的流量模式。本教程回顾了由两种不同方法引起的Trickbot感染的摘要：恶意垃圾邮件的Trickbot感染和通过其他恶意软件分发的Trickbot。</p>
<h2 id="0x01恶意垃圾邮件的Trickbot"><a href="#0x01恶意垃圾邮件的Trickbot" class="headerlink" title="0x01恶意垃圾邮件的Trickbot"></a>0x01恶意垃圾邮件的Trickbot</h2><p>Trickbot通常通过垃圾邮件进行分发。来自这些活动的电子邮件包含下载伪装成发票或文档的恶意文件的链接。这些文件可能是Trickbot的Windows可执行文件，也可能是Trickbot可执行文件的某种下载器。在某些情况下，这些电子邮件中的链接会返回一个包含Trickbot可执行文件或下载程序的zip存档。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/11/word-image-61-1024x554.png" alt="img"></p>
<p>图1显示了2019年9月的示例。在此示例中，电子邮件中包含一个返回zip存档的链接。zip存档包含一个Windows快捷方式文件，该文件下载了Trickbot可执行文件。有关相关的Trickbot感染的pcap信息，请参见此处。</p>
<p>图1：2019年9月来自垃圾邮件的Trickbot感染的流程图。</p>
<p>从此<a href="https://www.malware-traffic-analysis.net/2019/09/25/index.html下载pcap。" target="_blank" rel="noopener">https://www.malware-traffic-analysis.net/2019/09/25/index.html下载pcap。</a></p>
<p>查看流量，您会发现以下最新活动是Trickbot感染中常见的：</p>
<p>由受感染的Windows主机检查IP地址<br>通过TCP端口447和449的HTTPS/SSL/TLS流量<br>通过TCP端口8082的HTTP流量<br>以.png结尾的HTTP请求返回Windows可执行文件</p>
<p>这种Trickbot感染的独特之处在于，它向<a href="http://www.dchristjan.com发送了一个HTTP请求，该请求返回了一个zip归档文件；向144.91.69.195发送了一个HTTP请求，返回了一个Windows可执行文件。按照HTTP流向www.dchristjan.com的请求，如图3所示，以检查流量。在HTTP流中，您将找到指示已返回zip归档文件的指示符，如图4所示。" target="_blank" rel="noopener">www.dchristjan.com发送了一个HTTP请求，该请求返回了一个zip归档文件；向144.91.69.195发送了一个HTTP请求，返回了一个Windows可执行文件。按照HTTP流向www.dchristjan.com的请求，如图3所示，以检查流量。在HTTP流中，您将找到指示已返回zip归档文件的指示符，如图4所示。</a></p>
<p><img src="/Users/yueting/Library/ApplicationSupport/typora-user-images/image-20210403190439146.png" alt="image-20210403190439146"></p>
<p><img src="/Users/yueting/Library/ApplicationSupport/typora-user-images/image-20210403190615383.png" alt="image-20210403190615383"></p>
<p>图3：遵循HTTP流向<a href="http://www.dchristjan.com的请求。" target="_blank" rel="noopener">www.dchristjan.com的请求。</a></p>
<p>图4：指示HTTP请求返回了一个zip归档文件。<em>**InvoiceAndStatement.lnk\</em></p>
<p>从pcap导出zip存档。</p>
<p>在BSD，Linux或Mac环境中，您可以轻松地确认提取的文件是zip归档文件，获取文件的SHA256哈希，并在命令行环境中提取归档文件的内容。在这种情况下，内容是Windows快捷方式文件，您也可以确认并获取SHA256哈希</p>
<p><img src="/Users/yueting/Library/ApplicationSupport/typora-user-images/image-20210403190923101.png" alt="image-20210403190923101"></p>
<p>对144.91.69.195的HTTP请求返回了Windows可执行文件。这是Trickbot的初始Windows可执行文件。您可以遵循此HTTP请求的HTTP流，并找到指示符，它是一个可执行文件。您可以从pcap中提取可执行文件。</p>
<p><img src="/Users/yueting/Library/ApplicationSupport/typora-user-images/image-20210403191102789.png" alt="image-20210403191102789"></p>
<p>导出该文件。</p>
<p><img src="/Users/yueting/Library/ApplicationSupport/typora-user-images/image-20210403191244624.png" alt="image-20210403191244624"></p>
<p>感染后流量最初包括通过TCP端口443、447或449的HTTPS/SSL/TLS流量以及受感染Windows主机进行的IP地址检查。在这种感染中，HTTP请求Trickb之后不久执行文件，在通过TCP端口449成功连接到187.58.56.26之前，我们可以看到通过端口443尝试到不同IP地址的多个TCP连接。如果使用basic+过滤器，则可以看到这些尝试的连接，如图所示在图11和图12中。</p>
<p>![image-20210403191520797](/Users/yueting/Library/Application Support/typora-user-images/image-20210403191520797.png)</p>
<p>图11：被感染的Windows主机尝试通过端口443进行TCP连接。</p>
<p>![image-20210403191551565](/Users/yueting/Library/Application Support/typora-user-images/image-20210403191551565.png)</p>
<p>图12：向下滚动以查看通过端口443进行的更多TCP连接，然后再通过TCP端口449成功连接至187.58.56.26。</p>
<p>通过TCP端口447和TCP端口449到各种IP地址的HTTPS/SSL/TLS通信具有异常的证书数据。当使用Wireshark2.x时，我们可以通过对ssl.handshake.type==11进行过滤来检查证书颁发者；如果使用Wireshark3.x，则可以通过tls.handshake.type==11进行过滤。然后转到框架详细信息部分并展开信息，找到通往证书颁发者数据的方式，如图13和图14所示。</p>
<p>![image-20210403191730201](/Users/yueting/Library/Application Support/typora-user-images/image-20210403191730201.png)</p>
<p>图13：过滤HTTPS/SSL/TLS通信中的证书数据，然后展开行以显示TCP端口449下第一个结果的帧详细信息。</p>
<p>图14：通过TCP端口449向下钻取证书颁发者数据的第一个结果。</p>
<p>在图14中，我们看到以下证书颁发者数据用于通过TCP端口449到187.85.56.26的HTTPS/SSL/TLS通信中：</p>
<p>![image-20210403191919589](/Users/yueting/Library/Application Support/typora-user-images/image-20210403191919589.png)</p>
<p>id-at-countryName=AU<br>id-at-stateOrProvinceName=Some-State<br>id-at-organizationName=Internet Widgits Pty Ltd<br>州或省名（Some-State）和组织名（InternetWidgitsPtyLtd）不用于合法的HTTPS/SSL/TLS通信。<strong>这是恶意流量的指示，并且这种类型的异常证书颁发者数据不仅限于Trickbot。</strong>普通的证书颁发者在合法的HTTPS/SSL/TLS通信中是什么样的？如果我们查看通过TCP端口443到Microsoft域的早期通信（72.21.81.200），则会发现以下内容，如图15所示。</p>
<p>id-at-countryName=US<br>id-at-stateOrProvinceName=Washington<br>id-at-localityName=Redmond<br>id-at-organizationName=Microsoft Corporation<br>id-at-organizationUnitName=Microsoft IT<br>id-at-commonName=Microsoft IT TLS CA 2</p>
<p>![image-20210403192104205](/Users/yueting/Library/Application Support/typora-user-images/image-20210403192104205.png)</p>
<p>图15：从合法HTTPS流量到Microsoft域的证书数据。</p>
<p>受Trickbot感染的Windows主机将使用许多不同的IP地址检查站点来检查其IP地址。这些站点不是恶意的，流量本身也不是恶意的。但是，这种类型的IP地址检查在Trickbot和其他恶意软件家族中很常见。Trickbot使用的各种合法IP地址检查服务包括：</p>
<p>api.ip.sb<br>checkip.amazonaws.com<br>icanhazip.com<br>ident.me<br>ip.anysrc.net<br>ipecho.net<br>ipinfo.io<br>myexternalip.com<br>wtfismyip.com<br>同样，仅靠IP地址检查也不是恶意的。但是，这种活动与其他网络流量相结合可以提供感染迹象，就像我们在这种情况下看到的那样。</p>
<p>![image-20210403192159959](/Users/yueting/Library/Application Support/typora-user-images/image-20210403192159959.png)</p>
<p>图16：在通过TCP端口449进行HTTPS/SSL/TLS通信之后，受感染的Windows主机进行IP地址检查。并不是天生的恶意，但这是Trickbot感染的一部分。</p>
<p>Trickbot感染当前通过TCP端口8082生成HTTP通信，此通信从受感染的主机发送信息，例如来自浏览器缓存和电子邮件客户端的系统信息和密码。此信息从受感染的主机发送到Trickbot使用的命令和控制服务器。</p>
<p>要查看此流量，请使用以下Wireshark过滤器：</p>
<p>http.request and tcp.port eq 8082</p>
<p>这显示了以下HTTP请求，如图17所示：</p>
<p>![image-20210403192254064](/Users/yueting/Library/Application Support/typora-user-images/image-20210403192254064.png)</p>
<p>图17：由Trickbot导致的TCP端口8082上的HTTP流量。</p>
<p>以81结尾的HTTP POST请求从Web浏览器，电子邮件客户端和其他应用程序发送缓存的密码数据。以83结尾的HTTP POST请求发送由Web浏览器之类的应用程序提交的表单数据。我们可以找到通过以90结尾的HTTP POST请求发送的系统信息。对于这些HTT PPOST请求中的任何一个，请遵循TCP或HTTP流，以检查此感染所窃取的数据。</p>
<p>![image-20210403192545101](/Users/yueting/Library/Application Support/typora-user-images/image-20210403192545101.png)</p>
<p>图18：Trickbot从Chrome网络浏览器窃取的登录凭据。该数据是由受Trickbot感染的主机通过TCP端口8082通过HTTP流量发送的。</p>
<p>![image-20210403192817170](/Users/yueting/Library/Application Support/typora-user-images/image-20210403192817170.png)</p>
<p>图19：感染了Trickbot的主机通过TCP端口8082使用HTTP流量发送的系统数据。它开始与正在运行的进程列表。</p>
<p>![image-20210403192907940](/Users/yueting/Library/Application Support/typora-user-images/image-20210403192907940.png)</p>
<p>图20：感染了Trickbot的主机通过TCP端口8082使用HTTP流量发送的更多系统数据。该数据随后来自图19中启动的同一HTTP流。</p>
<p>Trickbot通过以.png结尾的HTTP GET请求发送更多Windows可执行文件。当受感染的Windows主机是Active Directory环境中的客户端时，这些后续Trickbot可执行文件用于感染易受攻击的域控制器（DC）。</p>
<p>您可以使用以下Wireshark过滤器在pcap中找到这些URL：</p>
<p>http.request and ip contains .png</p>
<p>![image-20210403192953711](/Users/yueting/Library/Application Support/typora-user-images/image-20210403192953711.png)</p>
<p>图21：过滤以查找使用以.png结尾的URL发送的后续TrickbotEXE文件。</p>
<p>在三个请求中的每个请求中遵循TCP或HTTP流，如图21所示。您应该看到类似于图9所示的Windows可执行文件指示符。但是，在这种情况下，HTTP响应标头将返回的文件标识为image/png，即使它显然是Windows可执行文件或DLL文件。</p>
<p>![image-20210403193047527](/Users/yueting/Library/Application Support/typora-user-images/image-20210403193047527.png)</p>
<p>图22：通过以.png结尾的URL发送的Windows可执行文件。</p>
<p>您可以从Wireshark导出这些文件，确认它们是Windows可执行文件，并获得本教程前面介绍的SHA256文件哈希。</p>
<h2 id="通过其他恶意软件分发的Trickbot"><a href="#通过其他恶意软件分发的Trickbot" class="headerlink" title="通过其他恶意软件分发的Trickbot"></a>通过其他恶意软件分发的Trickbot</h2><p>Trickbot经常通过其他恶意软件进行分发。Trickbot通常被视为Emotet感染的后续恶意软件，但我们也将其视为来自IcedID和Ursnif感染的后续恶意软件。</p>
<p>由于Emotet经常分发Trickbot，因此让我们在此处记录2019年9月的Emotet感染Trickbot的情况。去年我们在PaloAltoNetworks博客文章中已经将Emotet感染了Trickbot，因此本教程将重点介绍Trickbot的活动。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/11/word-image-88-1024x382.png" alt="img"></p>
<p>图23：带有Trickbot活动的Emotet的简化流程图。</p>
<p>从此<a href="https://www.malware-traffic-analysis.net/2019/11/13/index.html下载pcap。" target="_blank" rel="noopener">https://www.malware-traffic-analysis.net/2019/11/13/index.html下载pcap。</a></p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/11/word-image-89-1024x588.png" alt="img"></p>
<p>图24：过滤Emotet+Trickbot感染中的Web流量。</p>
<p>经验丰富的分析师通常可以识别Emotet生成的流量和Trickbot生成的流量。感染后的Emotet活动由HTTP流量和服务器返回的编码数据组成。这与感染后Trickbot活动明显不同，后者通常依赖HTTPS/SSL/TLS通信进行命令和控制通信。图25指出了该特定感染在Emotet和Trickbot之间的不同感染流量。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/11/word-image-90-1024x586.png" alt="img"></p>
<p>图25：Emotet和Trickbot流量的差异。</p>
<p>此感染发生在Active Directory环境中，其中10.9.25.102作为受感染的Windows客户端，而10.9.25.9作为DC。在稍后的流量中，我们看到DC表现出Trickbot感染的迹象，如图26所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/11/word-image-91-1024x535.png" alt="img"></p>
<p>图26：DC上的Trickbot活动。</p>
<p>感染是如何从客户转移到DC的？Trickbot使用一种版本的Eternal Blue漏洞利用Microsoft的SMB协议横向移动。在这种情况下，受感染的Windows客户端通过TCP端口445向DC的10.9.25.9发送了几次信息，然后DC从185.98.87.185/wredneg2.png中检索了Trickbot可执行文件。在DC呼出至185.98.87.185之前，使用basic+过滤器查看10.9.25.102处的客户端与10.9.25.9处的DC之间的通信的SYN段，如图27所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/11/word-image-92-1024x703.png" alt="img"></p>
<p>图27：在DC从196.98.87.185/wredneg2.png检索到Trickbot EXE之前，找到从10.9.25.102处的客户端到10.9.25.9处的DC（以灰色显示）的流量。</p>
<p>遵循以下TCP流之一，例如，该行在TCP端口49321上的源为10.9.25.102，在TCP端口445上的目标为10.9.35.9。这对于客户端发送到DC是非常不寻常的流量，因此它是可能与EternalBlue漏洞利用有关。有关此流量的示例，请参见图28。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/11/word-image-93-1024x725.png" alt="img"></p>
<p>图28：从客户端到TCP端口445到DC的异常流量的示例，可能与基于EternalBlue的利用有关。</p>
<p>除了这种异常的SMB流量和DC被感染之外，此pcap中任何Trickbot特定的活动都与我们之前的示例非常相似。</p>
<p>结论<br>本教程通过回顾从2019年9月开始的两个pcap提供了检查Trickbot恶意软件的Windows感染的技巧。可以在malware-traffic-analysis.net上找到更多包含Trickbot活动示例的pcap。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E6%A3%80%E6%9F%A5Ursnif%E6%84%9F%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E6%A3%80%E6%9F%A5Ursnif%E6%84%9F%E6%9F%93/" itemprop="url">Wireshark教程：检查Ursnif感染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-03T19:44:41+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Wireshark教程：检查Ursnif感染"><a href="#Wireshark教程：检查Ursnif感染" class="headerlink" title="Wireshark教程：检查Ursnif感染"></a>Wireshark教程：检查Ursnif感染</h1><p>Ursnif是一种银行恶意软件，有时也称为Gozi或IFSB。 Ursnif恶意软件家族已经活跃了很多年，当前的样本产生了不同的流量模式。</p>
<p>本教程使用Wireshark回顾感染Ursnif流量的数据包捕获（pcaps）。在检测和调查Ursnif感染时，了解这些流量模式对于安全专业人员至关重要。</p>
<h2 id="Ursnif分配方法"><a href="#Ursnif分配方法" class="headerlink" title="Ursnif分配方法"></a>Ursnif分配方法</h2><p>Ursnif可以通过基于Web的感染链和恶意垃圾邮件（malspam）进行分发。在某些情况下，Ursnif是由不同的恶意软件家族（如Hancitor）引起的后续感染，如最近的示例中所述。</p>
<p>我们经常在基于垃圾邮件的分发活动中找到Ursnif的示例，例如图1中的示例。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-42.jpeg" alt="img"></p>
<p>图1.来自更常见的Ursnif分发活动之一的流程图。</p>
<p>Ursnif流量类别<br>本教程涵盖了Ursnif感染流量的两类：</p>
<p>没有HTTPS感染后流量的Ursnif<br>具有HTTPS感染后流量的Ursnif<br>这些类别之一的恶意软件样本都会在受感染的Windows主机上创建相同类型的伪像。例如，通过更新Windows注册表，这两种类型的Ursnif都可以在Windows主机上保持持久性，如图2所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-43.jpeg" alt="img"></p>
<p>图2.由Ursnif样本引起的Windows注册表更新示例，带有或不带有HTTPS感染后流量。</p>
<h2 id="示例1：没有HTTPS的Ursnif"><a href="#示例1：没有HTTPS的Ursnif" class="headerlink" title="示例1：没有HTTPS的Ursnif"></a>示例1：没有HTTPS的Ursnif</h2><p>本教程的第一个pcap Ursnif-traffic-example-1.pcap在此处提供。此流量背后的事件链在此处发布了推文。实例1已删除与Ursnif感染没有直接关系的所有流量。</p>
<p>在Wireshark中打开pcap，然后对http.request进行过滤，如图3所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-44.jpeg" alt="img"></p>
<p>图3.示例1的pcap在Wireshark中进行了过滤。</p>
<p>在此示例中，受Ursnif感染的主机使用各种以.at结尾的域名生成到8.208.24.139的感染后流量。此类Ursnif导致以下流量：</p>
<p>由最初的Ursnif二进制文件引起的HTTP GET请求<br>后续数据的HTTP GET请求，URL以.dat结尾<br>Ursnif之后在Windows注册表中持续存在的HTTP GET和POST请求</p>
<p>在我们的第一个示例中，在通信过程中使用了以下HTTP数据：</p>
<p>初始GET请求的域：w8.wensa.at<br>请求后续数据：hxxp：//api2.casys.at / jvassets / xI / t64.dat<br>Ursnif之后GET和POST请求的域是持久的：h1.wensa.at</p>
<p>在20:13:09 UTC跟随TCP流进行第一个HTTP GET请求。 TCP流窗口显示完整的URL。请注意，GET请求如何以/ api1 /开头，后跟一串长的带有反斜杠和下划线的字母数字字符。图4突出显示了GET请求。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-45.jpeg" alt="img"></p>
<p>图4.由我们的第一个Ursnif示例引起的HTTP GET请求示例。</p>
<p>我们可以从2019年12月10日的Hancitor感染引起的Ursnif活动中找到相同的模式。 pcap在这里可用。 12月10日的示例与其他恶意软件活动混合在一起，包含有关Ursnif的以下指标：</p>
<p>初始GET请求的域：foo.fulldin.at<br>要求提供后续数据：hxxp：//one.ahah100.at / jvassets / o1 / s64.dat<br>Ursnif之后用于GET和POST请求的域是持久的：api.ahah100.at</p>
<p>请注意，12月10日示例中来自Ursnif流量的模式与我们在示例1中发现的模式如何相似。这些模式通常可以从不使用HTTPS流量的Ursnif样本中看到。</p>
<h2 id="示例2：带有HTTPS的Ursnif"><a href="#示例2：带有HTTPS的Ursnif" class="headerlink" title="示例2：带有HTTPS的Ursnif"></a>示例2：带有HTTPS的Ursnif</h2><p>本教程的第二个pcap Ursnif-traffic-example-2.pcap在此处提供。像我们的第一个pcap一样，也被剥夺了与Ursnif感染无关的所有流量。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-46.jpeg" alt="img"></p>
<p>如图5所示，在Wireshark中打开pcap并在http.request or ssl.handshake.type == 1上进行过滤。如果使用的是Wireshark 3.0或更高版本，则对http.request or tls.handshake.type == 1进行过滤正确的结果。</p>
<p>本示例具有以下事件序列：</p>
<p>返回初始Ursnif二进制文件的HTTP GET请求<br>由最初的Ursnif二进制文件引起的HTTP GET请求<br>Ursnif之后Windows注册表中的HTTPS通信持续存在</p>
<p>跟着到ghinatronx.com的第一个HTTP GET请求的TCP流。这个TCP流显示了Windows可执行文件或DLL文件，如图6所示。我们可以按照上一教程中的描述从pcap导出Ursnif二进制文件。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-47.jpeg" alt="img"></p>
<p>图6.第一个HTTP GET请求返回Ursnif的二进制文件。</p>
<p>接下来的四个对bjanicki.com的HTTP请求是由Ursnif二进制文件引起的。在世界标准时间18:46:21，跟随TCP流向bjanicki.com发送第一个HTTP GET请求。此TCP流显示完整的URL。请注意，GET请求如何以/ images /开头，后跟一串长的带有反斜杠和下划线的字母数字字符，然后以.avi结尾。此网址格式与我们第一个pcap中的Ursnif流量有些相似。图7突出显示了来自第二个pcap的GET请求。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-48.jpeg" alt="img"></p>
<p>图7.来自第二个Ursnif示例的HTTP GET请求示例。</p>
<p>与我们的第一个示例不同，第二个pcap中的Ursnif在被感染的Windows主机上变得持久后会生成HTTPS流量。使用此上一教程中描述的基本Web过滤器可以快速查看HTTPS流量。注意到prodrigo29lbkf20.com的HTTPS流量，如图8所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-49.jpeg" alt="img"></p>
<p>图8.在Wireshark中过滤Web流量，突出显示Ursnif生成的HTTPS流量。</p>
<p>此Ursnif变体生成的HTTPS通信揭示了用于建立加密通信的证书中的独特特征。为了更仔细地研究，请对ssl.handshake.type == 11（或在Wireshark 3.0或更高版本中为tls.handshake.type == 11）进行过滤。选择结果中的第一帧，然后转到帧详细信息窗口。在那里，我们可以扩展行并以自己的方式处理证书颁发者数据。图9显示了如何开始。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-50.jpeg" alt="img"></p>
<p>图9.找到我们的证书颁发者数据的方式。</p>
<p>如图9所示，我们在框架详细信息窗口中展开“安全套接字层”的行。对于Wireshark 3.0，此行显示为“传输层安全性”。然后，我们展开标记为TLSv1.2记录层：握手协议：证书的行。然后，我们展开标记为“握手协议：证书”的行。</p>
<p>我们一直在扩展，直到找到通往证书颁发者数据的方式为止，如图10所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-51.jpeg" alt="img"></p>
<p>图10.来自Ursnif导致的HTTPS流量中的证书颁发者数据。</p>
<p>在“握手协议：证书”行下显示的图10中，我们逐步完成以下各项：</p>
<ul>
<li>Certificates (615 bytes)</li>
<li>Certificate: 30820260308201c9a003020102020900c692c94106d77dfc…</li>
<li>signedCertificate</li>
<li>Issuer: rdnSequence (6)</li>
<li>rdnSequence: 6 items (id-at-commonName=*,id-at-organizationalUnitN…</li>
</ul>
<p>rdnSequence行下的各个项目显示证书颁发者的属性。这些具有以下特征：</p>
<ul>
<li>countryName=<strong>XX</strong></li>
<li>stateOrProvinceName=<strong>1</strong></li>
<li>localityName=<strong>1</strong></li>
<li>organizationName=<strong>1</strong></li>
<li>organizationalUnitName=<strong>1</strong></li>
<li>commonName=*****</li>
</ul>
<p>该发行者数据无效，这些模式在Ursnif感染中很常见。但是合法的证书数据是什么样的？图11显示了DigiCert颁发的证书中的有效数据。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-52.jpeg" alt="img"></p>
<p>图11.有效的证书颁发者数据。</p>
<p>关于Ursnif的最后一件事是由受Ursnif感染的主机检查IP地址。这是通过DNS使用opendns.com上的解析器进行的。像其他IP地址标识符一样，这是一项合法服务。但是，这些服务通常被恶意软件使用。</p>
<p>要查看此IP地址检查，dns.qry.name contains opendns.com过滤并查看结果，如图12所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-53.jpeg" alt="img"></p>
<p>图12.由受Ursnif感染的Windows主机检查IP地址。</p>
<p>如图12所示，Window主机生成了对resolver1.opendns.com的dns查询，然后是对myip.opendns.com的208.67.222.222的DNS查询。对myip.opendns.com的DNS查询返回了受感染Windows主机的公共IP地址。</p>
<h2 id="示例3：带有后续恶意软件的Ursnif"><a href="#示例3：带有后续恶意软件的Ursnif" class="headerlink" title="示例3：带有后续恶意软件的Ursnif"></a>示例3：带有后续恶意软件的Ursnif</h2><p>我们的第三个pcap Ursnif-traffic-example-3.pcap可在此处获得。这个pcap也从流量中剥离了无关的活动，但是它建立在我们的上一个示例的基础上。我们的第三个pcap包括看似诱骗的流量，还包括针对后续恶意软件的HTTP GET请求。事件的顺序是：</p>
<p>返回初始Ursnif二进制文件的HTTP GET请求<br>由最初的Ursnif二进制文件（包括诱骗URL）引起的HTTP GET请求<br>Ursnif之后Windows注册表中的HTTPS通信持续存在<br>针对后续恶意软件的HTTP GET请求<br>使用本上一教程中描述的基本Web过滤器可以快速查看基于Web的流量，如图13所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-54.jpeg" alt="img"></p>
<p>图13.在Wireshark中过滤第三个pcap以进行Web流量。</p>
<p>在图13中，对sinicaleer.com的初始HTTP请求为Ursnif返回了Windows可执行文件。图13中可见的剩余流量是由Ursnif可执行文件引起的，直到它变得持久为止。</p>
<p>对google.com的三个HTTP请求遵循与Ursnif流量相似的URL模式，即与ghdy656262oe.com的实际恶意域的通信。这些对google.com的HTTP GET请求似乎是诱饵流量，因为它们不起作用感染。通过TCP端口443到达gmail.com和<a href="http://www.google.com的HTTPS流量也没有直接的感染目的，该活动也可以归类为诱骗流量。图14显示了对google.com的诱骗HTTP" target="_blank" rel="noopener">www.google.com的HTTPS流量也没有直接的感染目的，该活动也可以归类为诱骗流量。图14显示了对google.com的诱骗HTTP</a> GET请求的示例。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-55.jpeg" alt="img"></p>
<p>图14.受Ursnif感染的主机诱骗HTTP GET请求到Google域。</p>
<p>请注意ghdy656262oe.com的HTTP流量。对ghdy656262oe.com的前两个GET请求返回404 Not Found响应，如图15所示。第三个HTTP GET请求返回200 OK响应，并且感染继续，如图16所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-56.jpeg" alt="img"></p>
<p>图15.对恶意Ursnif域的前两个HTTP GET请求返回404 Not Found响应。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-57.jpeg" alt="img"></p>
<p>图16.在Ursnif感染继续之前，一些错误的开始。</p>
<p>由于对ghdy656262oe.com的第一个HTTP GET请求不是200 OK，因此，受感染的Windows主机循环遍历其他恶意域以继续感染。这两个域是tnzf3380au [.top]和xijamaalj.com。但是，对这些域的DNS查询返回“ No such name”（无此名称）作为响应，因此受感染的Windows主机又返回尝试ghdy656262oe.com。</p>
<p>使用以下Wireshark筛选器可以更好地查看此事件序列：</p>
<p>((http.request or http.response) and ip.addr eq 194.1.236.191) or dns.qry.name contains tnzf3380au or dns.qry.name contains xijamaalj</p>
<p>结果应类似于图17中的列显示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-58.jpeg" alt="img"></p>
<p>图17.过滤以显示受感染的Windows主机如何在HTTP流量达到200 OK之前尝试与Ursnif相关的域。</p>
<p>要查看其余感染，请使用基本的Web过滤器并滚动到结果的结尾。图18显示了Ursnif持续存在后的感染后流量。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-59.jpeg" alt="img"></p>
<p>图18. Ursnif在受害者的Windows主机上持续存在后的感染后流量。</p>
<p>在图18中，在对ghdy656262oe.com进行了五个HTTP GET请求之后，我们发现在Ursnif变得持久之后，被感染的Windows主机生成的流量。这包括到google.com和gmail.com的HTTPS流量。</p>
<p>进入vnt69tnjacynthe [.com]的流量应与我们在第二封pcap中看到的类型相同的证书颁发者数据。但是，此流量包括对以.rar结尾的carresqautomotive.com的HTTP GET请求。</p>
<p>以.rar结尾的URL返回了后续恶意软件。但是，这种后续恶意软件在通过网络发送时会被编码或以其他方式加密。在受感染的Windows主机上解码的二进制文件，在感染流量中看不到。按照TCP流对carresqautomotive.com的HTTP GET请求进行操作，您应该看到与图19相同的数据。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-60.jpeg" alt="img"></p>
<p>图19.发送到受Ursnif感染的Windows主机的后续恶意软件。</p>
<p>此数据已加密，因此我们无法从pcap导出后续恶意软件的副本。因此，我们必须依靠其他感染后流量来确定将哪种类型的恶意软件发送给受Ursnif感染的主机。</p>
<p>我们已经看到来自Ursnif感染的各种后续恶意软件，包括Dridex，IcedID，Nymain，Pushdo和Trickbot。</p>
<p>我们的下一个示例是使用Dridex作为后续恶意软件的Ursnif感染。</p>
<h2 id="实施例4：用Dridex感染Ursnif"><a href="#实施例4：用Dridex感染Ursnif" class="headerlink" title="实施例4：用Dridex感染Ursnif"></a>实施例4：用Dridex感染Ursnif</h2><p>我们的第四个pcap Ursnif-traffic-example-4.pcap可在此处获得。与前三个示例不同，此pcap不会从流量中剥离无关的活动。</p>
<p>使用基本的Web过滤器可以更好地了解流量。您的结果应类似于图20。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-61.jpeg" alt="img"></p>
<p>图20.来自第四个pcap的流量在Wireshark中进行了过滤。</p>
<p>这个pcap的事件序列与我们之前的示例相同，但是它增加了后续恶意软件的感染后活动：</p>
<p>返回初始Ursnif二进制文件的HTTP GET请求<br>由最初的Ursnif二进制文件（包括诱骗URL）引起的HTTP GET请求<br>Ursnif之后Windows注册表中的HTTPS通信持续存在<br>针对后续恶意软件的HTTP GET请求<br>后续恶意软件的感染后活动<br>在第四个示例中，初始Ursnif二进制文件的HTTP GET请求是oklogallem.com。在感染持续存在之前，Ursnif导致对kh2714ldb.com的HTTP GET请求。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-62.jpeg" alt="img"></p>
<p>图21显示了Ursnif持久后的活动，其中Ursnif导致到s9971kbjjessie.com的HTTPS通信。然后，我们看到对startuptshirt.my的HTTP GET请求，以获取后续恶意软件。最后，我们发现了由后续恶意软件引起的感染后流量。</p>
<p>我们的第四个示例遵循与我们的第三个pcap相同的感染模式，但是现在我们还具有到94.140.114.6和5.61.34.51的HTTPS / SSL / TLS流量，而没有任何关联的域名。这是Dridex感染后的流量。</p>
<p>Dridex的证书颁发者数据与Ursnif的证书颁发者数据不同。使用以下过滤器查看第四个pcap中的Dridex证书数据：</p>
<p>（ip.addr eq 94.140.114.6 or ip.addr eq 5.61.34.51）and ssl.handshake.type eq 11</p>
<p>注意：如果您使用的是Wireshark 3.0或更高版本，请使用tls.handshake.type而不是ssl.handshake.type。</p>
<p>选择结果中的第一帧，转到帧详细信息窗口，并展开与证书相关的行，如图9和10中的第二个示例所示。从我们的第四个pcap中检查证书颁发者数据应类似于图22和23。 </p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-63.jpeg" alt="img"></p>
<p>图22.在Dridex通信中处理证书颁发者数据的方式。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-64.jpeg" alt="img"></p>
<p>图23.从Dridex IP地址之一到达证书颁发者数据。</p>
<p>在rdnSequence行下，我们找到证书颁发者的属性。以下是94.140.114.6的HTTPS / SSL / TLS通信的证书颁发者特征：</p>
<ul>
<li>countryName=<strong>NP</strong></li>
<li>localityName=<strong>Kathmandu</strong></li>
<li>organizationName=<strong>Buvecoww Fftaites O.V.E.E.</strong></li>
<li>organizationalUnitName=<strong>Olfo Dusar Latha</strong></li>
<li>commonName=<strong>ndltman-dsamutb.spiegel</strong></li>
</ul>
<p>证书颁发者数据对于5.61.34.51是不同的，但是它遵循类似的样式：</p>
<ul>
<li>countryName=<strong>MU</strong></li>
<li>localityName=<strong>Port Louis</strong></li>
<li>organizationName=<strong>Ppoffi Sourinop Cooperative</strong></li>
<li>organizationalUnitName=<strong>ipeepstha and thicioi</strong></li>
<li>commonName=<strong>plledsaprell.Byargt9wailen.voting</strong></li>
</ul>
<p>对于Dridex感染后流量，通常会看到这种类型的发行者数据。在我们的下一个示例中，您可以进一步练习查看Dridex的证书颁发者数据。</p>
<h2 id="示例5：评估"><a href="#示例5：评估" class="headerlink" title="示例5：评估"></a>示例5：评估</h2><p>本教程的第五篇pcap Ursnif-traffic-example-5.pcap在此处提供。像我们之前的示例一样，此pcap感染了Ursnif，然后是Dridex，因此，我们可以练习本教程到目前为止介绍的技能。</p>
<p>根据到目前为止的经验，在Wireshark中打开第五个pcap，然后回答以下问题：</p>
<p>对于最初的Ursnif二进制文件，哪个URL返回了Windows可执行文件？<br>发送初始Ursnif二进制文件后，受感染的Windows主机联系了其他域以获取HTTP GET请求。流量成功进入哪个域并允许感染继续进行？<br>Ursnif在受感染的Windows主机上持续存在之后，HTTPS流量中使用了哪个域？<br>以.rar结尾的URL用于将后续恶意软件发送到受感染的Windows主机？<br>Dridex感染后流量使用了哪些IP地址？<br>答案如下。</p>
<p>问：对于最初的Ursnif二进制文件，哪个URL返回了Windows可执行文件？</p>
<p>答：hxxp：// ritalislum.com / obedle / zarref.php？l = sopopf8.cab</p>
<p>此pcap中唯一的Windows可执行文件是Ursnif的初始Windows可执行文件。使用以下Wireshark搜索过滤器可以快速找到此可执行文件：</p>
<p><strong><em>ip contains “This program”\</em></strong></p>
<p>此过滤器应仅在结果中提供一帧。遵循此帧的TCP流，如图24所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-65.jpeg" alt="img"></p>
<p>图24.进行筛选以找到带有Windows可执行文件并遵循TCP流的框架。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-66.jpeg" alt="img"></p>
<p>TCP流窗口包含来自GET请求的域和URL，如图25所示。</p>
<p>图25.来自TCP流的URL信息。</p>
<p>问：最初的Ursnif二进制文件发送后，受感染的Windows主机就HTTP GET请求联系了不同的域。流量成功通过了哪个域并允许感染继续进行？</p>
<p>答：k55gaisi.com</p>
<p>使用基本的Web过滤器可大致了解Web流量。由Ursnif的这种变体引起的HTTP请求以GET / images /开头，如本教程的示例2、3和4所示。 UTC在15:36 UTC向k55gaisi.com发出的第一个HTTP请求记录在图26中。但是，如果您遵循TCP流，它将显示404 Not Found作为响应。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-67.jpeg" alt="img"></p>
<p>图26.在Web流量中搜索Ursnif引起的HTTP GET请求。</p>
<p>如图26所示，下一个针对Ursnif样式的URL的HTTP GET请求是在世界标准时间15:37向bon11ljgarry.com发送。该请求的HTTP流显示了到<a href="http://www.search-error.com上URL的重定向。" target="_blank" rel="noopener">www.search-error.com上URL的重定向。</a></p>
<p>向下滚动，以获取与leinwqoa.com类似的流量，如图27所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-68.jpeg" alt="img"></p>
<p>图27.查找另一个Ursnif风格的URL，该URL重定向到搜索错误页面。</p>
<p>进一步向下滚动以找到四个k55gaisi.com的HTTP GET请求，这些请求返回200 OK响应。从这一点开始，Ursnif感染继续进行，我们发现没有其他以GET / images /开头的Ursnif样式的HTTP请求。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-69.jpeg" alt="img"></p>
<p>图28.查找返回200 OK的Ursnif风格的HTTP GET请求。</p>
<p>问：Ursnif在受感染的Windows主机上持续存在之后，HTTPS流量中使用了哪个域？</p>
<p>答：n9maryjanef.com</p>
<p>当Ursnif是永久性的时，我们不再看到以GET / images /开头的Ursnif样式的HTTP请求。相反，我们找到了与Ursnif相关的HTTPS流量。在最后的Ursnif样式的HTTP GET请求之后不久，到n9maryjanef.com的HTTPS流量从185.118.165.109开始，如图29突出显示。这是Ursnif流量。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-70.jpeg" alt="img"></p>
<p>图29. Ursnif引起的HTTPS流量。</p>
<p>您可以通过过滤ip.addr eq 185.118.165.109和ssl.handshake.type == 11并查看证书颁发者数据来确认这是Ursnif流量。证书颁发者的数据应与图10中的第二个示例相同。</p>
<p>问：以.rar结尾的URL用于将后续恶意软件发送到受感染的Windows主机吗？</p>
<p>答：hxxps：// testedsolutionbe.com / wp-content / plugins / apikey / uaasdqweeeeqsd.rar</p>
<p>Ursnif对后续恶意软件引起的HTTP GET请求以.rar结尾，因此请使用以下过滤器在我们的pcap中找到此URL：</p>
<p>http.request和ip包含.rar</p>
<p>结果应该类似于我们在图30中看到的结果。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-71.jpeg" alt="img"></p>
<p>图30.从Ursnif感染中查找后续恶意软件的URL。</p>
<p>注意，在图30中，图30中的HTTP GET请求如何重定向到HTTPS URL。</p>
<p>问：Dridex感染后流量使用了哪些IP地址？</p>
<p>A：185.99.133.38和5.61.34.51</p>
<p>这些IP地址之一与我们的第四个pcap中的Dridex相同，并且具有相同的证书颁发者数据。到185.99.133.38的Dridex流量具有与示例4相同的证书颁发者数据样式。到两个IP地址的流量均不涉及域名。</p>
<p>如果在以.rar结尾的HTTP GET请求之后查找没有域的任何HTTPS / SSL / TLS通信，则在此示例中很容易发现Dridex感染后通信，如图31所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/12/word-image-72.jpeg" alt="img"></p>
<p>图31.在第五个pcap中查找Dridex流量。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本教程提供了有关检查Ursnif恶意软件Windows感染的提示。可以在恶意软件traffic-analysis.net上找到有关Ursnif活动示例的更多内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E6%A3%80%E6%9F%A5Qakbot%E6%84%9F%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E6%A3%80%E6%9F%A5Qakbot%E6%84%9F%E6%9F%93/" itemprop="url">Wireshark教程：检查Qakbot感染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-03T19:43:38+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Wireshark教程：检查Qakbot感染"><a href="#Wireshark教程：检查Qakbot感染" class="headerlink" title="Wireshark教程：检查Qakbot感染"></a>Wireshark教程：检查Qakbot感染</h1><p>概述<br>Qakbot是一个信息窃取者，也称为Qbot。该恶意软件家族已经活跃了很多年，并且Qakbot产生了独特的流量模式。这份Wireshark教程回顾了最近从Qakbot感染中捕获的数据包（pcap）。在检测和调查Qakbot感染时，了解这些流量模式对于安全专业人员至关重要。</p>
<p>Qakbot感染流量</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/PB-210-image-01-1024x641.jpg" alt="Qakbot Infection Traffic"></p>
<p>图1.本教程的pcap。</p>
<h2 id="Qakbot分配方法"><a href="#Qakbot分配方法" class="headerlink" title="Qakbot分配方法"></a>Qakbot分配方法</h2><p>Qakbot最常通过恶意垃圾邮件（malspam）进行分发，但直到2019年11月，它也已通过漏洞利用工具包进行分发。在某些情况下，Qakbot是由不同的恶意软件（例如Emotet）引起的后续感染，如本示例中所述2019年3月。</p>
<p>最近针对Qakbot的基于垃圾邮件的分发活动遵循一系列事件，如图2所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-29-1024x618.jpeg" alt="img"></p>
<p>图2.最近Qakbot分发活动的流程图。<br>来自Malspam中Link的初始Zip存档<br>最近分发Qakbot的恶意垃圾邮件使用伪造的电子邮件链来欺骗合法电子邮件地址。图3显示了一个这样的示例。</p>
<p>Qakbot感染</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-30-1024x821.jpeg" alt="Qakbot Infections">图3.最近的垃圾邮件示例推动了Qakbot。<br>这些电子邮件的URL以一小段数字结尾，后跟.zip。有关最近在URLhaus和Twitter上报告的来自Qakbot malspam的URL的一些示例，请参见表1。</p>
<p>最初的zip存档的第一个报告URL<br>![image-20210403203244456](/Users/yueting/Library/Application Support/typora-user-images/image-20210403203244456.png)<br>表1.用于启动Qakbot感染链的初始zip存档的URL。</p>
<p>在我们的pcap中，您可以使用Wireshark过滤器中的http.request.uri包含.zip的zip存档找到HTTP请求，如图4所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-31-1024x263.jpeg" alt="Qakbot Infections"><br>图4.查找初始zip存档的URL。<br>按照TCP流确认这是一个zip存档，如图5和图6所示，然后尝试从pcap导出zip存档，如图7所示。<br>在大多数情况下，“文件”→“导出对象”→“ HTTP”菜单应导出通过HTTP发送的zip存档。不幸的是，如图8所示，我们无法导出名为9312.zip的文件，因为它在导出HTTP对象列表中被分成数百个较小的部分。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-33-1024x750.jpeg" alt="img"></p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-35-1024x757.jpeg" alt="img"></p>
<p>图8. 9312.zip在列表中被分解为数百个对象，因此我们无法以这种方式导出它。<br>幸运的是，我们可以从TCP流窗口中导出数据，并在十六进制编辑器中编辑二进制文件以删除任何hxxP响应标头。使用以下步骤从该pcap中提取zip存档：</p>
<p>跟随TCP流以获取对9312.zip的HTTP请求。<br>仅显示TCP中的响应流量流窗口。<br>将“显示和保存数据为”从ASCII更改为Raw。<br>将数据另存为二进制文件（我选择将其另存为：9312.zip.bin）<br><strong>在十六进制编辑器中打开二进制文件，并删除zip归档文件的前两个字节（以ASCII形式显示为PK）之前的HTTP请求标头。</strong><br><strong>将文件另存为zip存档（我选择将其另存为9312.zip）</strong><br>检查文件以确保它是zip存档。<br>有关此过程的直观指南，请参见图9至14。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-36-1024x675.jpeg" alt="Qakbot Infections"></p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-39-1024x609.jpeg" alt="Qakbot Infections">图14.步骤7-确认编辑的文件是zip存档，然后解压缩VBS文件并检查文件哈希。<br>图14显示了如何使用基于Debian的Linux发行版中的终端窗口来检查文件。从我们的pcap中，zip存档应与提交给VirusTotal的该文件相同。我们提取的VBS文件应与还提交给VirusTotal的该文件相同。</p>
<p>对提取的VBS文件进行的公共沙盒分析表明，它会在感染链中生成与Qakbot相关的下一个URL：该URL返回Qakbot的Windows可执行文件。</p>
<h2 id="适用于Qakbot的Windows可执行文件"><a href="#适用于Qakbot的Windows可执行文件" class="headerlink" title="适用于Qakbot的Windows可执行文件"></a>适用于Qakbot的Windows可执行文件</h2><p>这些提取的VBS文件生成URL，这些URL返回Qakbot的Windows可执行文件。自2019年12月以来，用于Qakbot可执行文件的URL以44444.png或444444.png结尾。有关我们使用AutoFocus威胁情报服务发现的这些Qakbot URL的最新示例，请参见表2。</p>
<p>Qakbot可执行文件的首次看到的URL<br>![image-20210403203603337](/Users/yueting/Library/Application Support/typora-user-images/image-20210403203603337.png)<br>表2. Qakbot可执行文件的URL。</p>
<p>在我们的pcap中，使用Wireshark过滤器中的hxxp.request.uri包含.png的Qakbot可执行文件找到HTTP GET请求，如图15所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-42-1024x258.jpeg" alt="Qakbot Infections"><br>图15.查找我们的Qakbot可执行文件的URL。<br>使用File→Export Objects→HTTP菜单路径从pcap导出该对象，如图16所示，并检查结果，如图17所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-43-1024x506.jpeg" alt="Qakbot Infections"><br>图17.在基于Debian的Linux终端窗口中检查导出的文件。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-44-1024x276.jpeg" alt="Qakbot Infections">从我们的pcap中，Qakbot可执行文件应该是将此文件提交给VirusTotal。对该文件的公共沙箱分析生成了多个Qakbot指标（标识为Qbot）。</p>
<h2 id="感染后HTTPS活动"><a href="#感染后HTTPS活动" class="headerlink" title="感染后HTTPS活动"></a>感染后HTTPS活动</h2><p>使用您的基本过滤器（在上一本Wireshark教程中可以找到）来快速查看pcap中的网络流量。向alphaenergyeng . com发送HTTP GET请求后，向下滚动到活动，该活动返回了我们的Qakbot可执行文件。您应该看到一些指向68.1.115 . 106的HTTPS或SSL / TLS流量的指示器，没有相关的域，如图18所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-45-1024x608.jpeg" alt="Qakbot Infections"><br>图18. Qakbot引起的HTTPS或SSL / TLS流量。<br>此流量具有在Qakbot感染期间通常注意到的异常证书颁发者数据。我们在以前的有关Ursnif的WIreshark教程中回顾了异常的证书颁发者数据，因此应该很容易找到。</p>
<p>让我们使用以下Wireshark过滤器查看我们的Qakbot证书颁发者数据：</p>
<p>ip.addr eq 68.1.115.186 and ssl.handshake.type eq 11</p>
<p>对于Wireshark 3.0或更高版本，请使用tls.handshake.type而不是ssl.handshake.type。选择结果中的第一帧，然后展开帧详细信息窗口，直到找到证书颁发者数据为止，如图19所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-46-1024x723.jpeg" alt="Qakbot Infections"><br>图19.从Qakbot流量查看证书颁发者数据。<br>区域名称，组织名称和通用名称的模式非常不常见，通常不会在来自合法HTTPS，SSL或TLS流量的证书中找到。我们的前下面列出了很多此发行者数据：</p>
<ul>
<li>id-at-countryName=<strong>ES</strong></li>
<li>id-at-stateOrProvinceName=<strong>IA</strong></li>
<li>id-at-localityName=<strong>Uorh Ofwa</strong></li>
<li>id-at-organizationName=<strong>Coejdut Mavmtko Qxyemk Dxsjie LLC.</strong></li>
<li>id-at-commonName=<strong>gaevietovp.mobi</strong></li>
</ul>
<h2 id="其他感染后流量"><a href="#其他感染后流量" class="headerlink" title="其他感染后流量"></a>其他感染后流量</h2><p>我们的pcap包含与Qakbot感染相关的其他活动。每种活动本身都不具有固有的恶意性，但结合我们先前的发现，我们可以假定完全受到Qakbot感染。</p>
<p>Qakbot感染的另一个指标是到cdn.speedof . me的HTTPS流量。合法的Internet速度测试服务使用domain speedof . me。尽管这不是恶意流量，但在Qakbot感染期间，我们经常看到到cdn.speedof . me的流量。图20从我们的pcap中显示了此活动。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-47-1024x622.jpeg" alt="img"></p>
<p>图20. Qakbot通信中的域cdn.speedof . me。<br>Qakbot还会从受感染的Windows主机上的所有浏览器中打开窗口。在进行此沙箱分析的大约13分5秒时，视频播放显示Qakbot在Windows 7主机上打开Chrome，然后是Firefox，然后是Internet Explorer。该分析显示了Qakbot生成的访问以下URL的流量：<br>hxxp：//store.nvprivateoffice . com / redir_chrome.html<br>hxxp：//store.nvprivateoffice . com / redir_ff.html<br>hxxp：//store.nvprivateoffice . com / redir_ie.html</p>
<p>自2012年以来，域nvprivateoffice . com已通过GoDaddy注册，并且store.nvprivateoffice . com在Fedora服务器上显示nginx的默认网页。</p>
<p>本教程的pcap来自未安装Chrome或Firefox的Windows 10主机上的Qakbot感染。我们的pcap仅显示Internet Explorer和新的基于Chromium的Microsoft Edge的网络流量。两次，Qakbot生成的URL为hxxp：//store.nvprivateoffice . com / redir_ie.html。</p>
<p>要查找此流量，请使用以下Wireshark过滤器，如图21所示：</p>
<p>http.request.full_uri contains store.nvprivateoffice</p>
<p><strong><em>http.request.full_uri contains store.nvprivateoffice</em></strong></p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-48-1024x315.jpeg" alt="img"></p>
<p>图21.查找在受感染的Windows主机上打开Web浏览器的Qakbot通信。<br>按照两个以redir_ie.html结尾的HTTP GET请求中的每一个的TCP流。第一个请求在Internet Explorer的HTTP标头中具有一个User-Agent，如图22所示。对于同一URL的第二个请求在新的基于Chromium的Microsoft Edge的HTTP标头中具有一个User-Agent，如图23所示。 </p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-49-1024x757.jpeg" alt="img"></p>
<p>图22.使用Internet Explorer 11到Qakbot到store.nvprivateoffice . com的流量。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-50-1024x758.jpeg" alt="img"></p>
<p>图23.使用新的基于Chromium的Microsoft Edge到Qakbot到store.nvprivateoffice . com的流量。<br>最后，来自受Qakbot感染的主机的pcap还具有与电子邮件相关的TCP流量，该TCP流量到各种端口的各种端口，例如SMTP，IMAP和POP3。要了解与网络无关的流量，请使用以下Wireshark过滤器，如图25所示：<br>tcp.flags eq 0x0002 and !(tcp.port eq 80) and !(tcp.port eq 443)</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-51-1024x864.jpeg" alt="img"></p>
<p>图25.了解来自此Qakbot感染的非Web流量。<br>图25显示了到不同电子邮件协议通常使用的各种端口（如25、110、143、465、587、993和995）的TCP连接和尝试的TCP连接。结果的前两行显示了到TCP端口65400的流量，但是查看关联的TCP流则表明这也是与电子邮件相关的流量。</p>
<p>使用以下Wireshark筛选器可以更好地了解受感染主机的电子邮件相关流量，如图26所示：</p>
<p>smtp or imap or pop</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/02/word-image-52-1024x628.jpeg" alt="img"></p>
<p>图26.在此pcap中查找由Qakbot引起的与电子邮件相关的流量。<br>遵循一些TCP流，以更好地了解此类电子邮件流量。通常，我们不会看到从Windows客户端到公用IP地址的这种未加密电子邮件流量。连同其他指示器一起，此smtp或imap或pop过滤器可能会揭示Qakbot的活动。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本教程提供了有关使用Qakbot恶意软件检查Windows感染的提示。可以在malware-traffic-analysis.net上找到更多带有Qakbot活动示例的pcap。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E6%A3%80%E6%9F%A5Dridex%E6%84%9F%E6%9F%93%E6%B5%81%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E6%A3%80%E6%9F%A5Dridex%E6%84%9F%E6%9F%93%E6%B5%81%E9%87%8F/" itemprop="url">Wireshark教程：检查Dridex感染流量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-03T19:42:35+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Wireshark教程：检查Dridex感染流量"><a href="#Wireshark教程：检查Dridex感染流量" class="headerlink" title="Wireshark教程：检查Dridex感染流量"></a>Wireshark教程：检查Dridex感染流量</h1><p>本教程适用于调查可疑网络活动并查看网络数据包捕获（pcaps）的安全专业人员。必须熟悉Wireshark才能理解本教程，该教程侧重于Wireshark版本3.x。</p>
<p>Dridex是一类信息窃取恶意软件的名称，也被称为银行木马。该恶意软件于2014年首次出现，并一直活跃至今。</p>
<p>今天的Wireshark教程回顾了Dridex的活动，并提供了一些有关基于流量分析来识别此家庭的有用提示。</p>
<h2 id="Dridex分布"><a href="#Dridex分布" class="headerlink" title="Dridex分布"></a>Dridex分布</h2><p>要了解Dridex网络流量，您应该了解导致感染的事件链。 Dridex通常是通过恶意垃圾邮件（malspam）分发的。这种垃圾邮件的浪潮通常每周至少发生两次或三次。一些发送Dridex的电子邮件包含附加的Microsoft Office文档，而另一些电子邮件则包含下载恶意文件的链接。图1至图4显示了一些最近的示例。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-2.jpeg" alt="An email carrying a malicious Excel file, pushing Dridex, with the subject line &quot;DHL Invoices for Aug 2020&quot;"></p>
<p>一封带有恶意Excel文件的电子邮件，推送了Dridex，主题行为“ 2020年8月DHL发票”<br>图1.从2020年9月开始，以DHL为主题的垃圾邮件使用附件推动Dridex。<br>一封使用附加的恶意Excel文件推送Dridex的电子邮件。主题行是“ UPS发票通知”。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-3.jpeg" alt="An email pushing Dridex using an attached malicious Excel file. The subject line is &quot;UPS Invoice Notification.&quot; "></p>
<p>图2.从2020年10月开始，以UPS为主题的垃圾邮件使用附件推动Dridex。<br>一封使用恶意链接推送Dridex的电子邮件。主题行是“联邦快递发货747958837531已交付”。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-4.jpeg" alt="An email pushing Dridex using a malicious link. The subject line is &quot;FedEx Shipment 747958837531 Delivered.&quot; "></p>
<p>图3.从2020年9月开始，以联邦快递为主题的垃圾邮件使用链接推动Dridex。<br>一封使用恶意链接推送Dridex的电子邮件。主题行是“通知：发票796636”。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-5.jpeg" alt="An email pushing Dridex using a malicious link. The subject line is &quot;Notification : invoice 796636.&quot; "></p>
<p>图4.从2020年10月开始，以QuickBooks为主题的垃圾邮件使用链接推送Dridex。<br>初始恶意文件可以是带有恶意宏的Microsoft Office文档，也可以是伪装为某种文档的Windows可执行文件（EXE）。无论哪种方式，潜在的受害者都需要点击此初始文件中的感染路径。初始文件将检索Dridex安装程序，尽管有时初始文件本身就是Dridex安装程序。 Dridex安装程序通过加密的命令和控制（C2）网络流量检索64位Dridex DLL文件。图5和图6显示了我们对最近Dridex活动的感染链的普遍看法。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-6.jpeg" alt="Malspam with attached spreadsheets pushing Dridex. The chain of events is as follows: malspam with attachment, attached Excel spreadsheet, enable macros, HTTPS traffic for installer DLL, installer DLL for Dridex, HTTPS C2 traffic, 64-bit Dridex DLL files, HTTPS C2 traffic, updated 64-bit Dridex DLL files"></p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-7.jpeg" alt="Malspam with links pushing Dridex. Chain of events is commonly as follows: malspam with HTTPS link, HTTPS traffic for Word doc, downloaded Word doc, enable macros, HTTPS traffic for installer DLL, installer DLL for Dridex, HTTPS C2 traffic, 64-bit Dridex DLL files, HTTPS C2 traffic, updated 64-bit Dridex DLL files"></p>
<p>带有附加电子表格的垃圾邮件推送Dridex。事件链如下：带附件的垃圾邮件，附加的Excel电子表格，启用宏，安装程序DLL的HTTPS流量，Dridex的安装程序DLL，HTTPS C2流量，64位Dridex DLL文件，HTTPS C2流量，更新的64位Dridex DLL文件<br>图5.当Dridex作为垃圾邮件附件分发时，通常可以看到的事件链。<br>带有推动Dridex的链接的垃圾邮件。事件链通常如下：带HTTPS链接的垃圾邮件，Word文档的HTTPS通信，下载的Word文档，启用宏，安装程序DLL的HTTPS通信，Dridex的安装程序DLL，HTTPS C2通信，64位Dridex DLL文件，HTTPS C2流量，更新的64位Dridex DLL文件<br>图6.使用垃圾邮件中的链接分发Dridex时通常看到的事件链。<br>图7显示了来自垃圾邮件的另一种Dridex感染链，与图5和6中使用的Office文档并不相同。到2020年9月24日，来自垃圾邮件的链接推动Dridex并未返回Office文档。相反，他们返回了Windows可执行文件。有关详细信息，请参见图7。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-8.jpeg" alt="Malspam pushing Dridex on Thursday 2020-09-24, Note: Occasionally, the same HTTPS link returned an EXE with an .scr file extension instead of a ZIP archive. The chain of events seen was as follows: malspam with HTTPS link, HTTPS traffic for ZIP archive, downloaded ZIP archive, Dridex installer EXE (.scr file extension), HTTPS C2 traffic, 64-bit Dridex DLL files, HTTPS C2 traffic, updated 64-bit Dridex DLL files"></p>
<p>malspam在2020-09-24星期四推送Dridex，注意：有时，同一HTTPS链接返回的文件扩展名为.scr而不是ZIP存档的EXE。看到的事件链如下：带有HTTPS链接的垃圾邮件，ZIP存档的HTTPS流量，已下载的ZIP存档，Dridex安装程序EXE（.scr文件扩展名），HTTPS C2流量，64位Dridex DLL文件，HTTPS C2流量，已更新64位Dridex DLL文件<br>图7：在2020年9月看到的事件链，其中的链接导致了Dridex安装程序EXE。<br>如图5到7所示，分发流量通常是HTTPS，它使初始文件或由于Dridex安装程序是加密的，因此很难检测到。幸运的是，由Dridex C2活动引起的感染后流量足以识别。</p>
<h2 id="证书和HTTPS流量"><a href="#证书和HTTPS流量" class="headerlink" title="证书和HTTPS流量"></a>证书和HTTPS流量</h2><p>要了解Dridex感染活动，我们还应该了解用于HTTPS流量的数字证书。</p>
<p>数字证书用于HTTPS流量的SSL / TLS加密。使用HTTPS查看网站时，Web服务器会将证书发送到客户端的Web浏览器。来自此数字证书的数据用于建立HTTPS连接。证书包含网站的公共密钥，并确认网站的身份。</p>
<p>不同的证书颁发机构（CA）可以为各种网站颁发数字证书。证书被出售给商业网站的企业，而一些证书颁发机构（如Let’s Encrypt）则免费提供证书。</p>
<p>可以从Wireshark中的HTTPS通信中查看证书信息。我们将重点关注以下两个部分：</p>
<p>有关CA的颁发者数据。<br>有关网站的主题数据。<br>颁发者数据显示颁发了数字证书的CA。主题数据验证网站的身份。图8显示了如何从<a href="http://www.paloaltonetworks.com查找HTTPS流量的证书颁发者和主题数据。" target="_blank" rel="noopener">www.paloaltonetworks.com查找HTTPS流量的证书颁发者和主题数据。</a></p>
<p>屏幕截图显示了如何使用<a href="http://www.paloaltonetworks.com作为示例来查找HTTPS流量的证书颁发者和主题日期。红色框突出显示主题数据以标识网站。" target="_blank" rel="noopener">www.paloaltonetworks.com作为示例来查找HTTPS流量的证书颁发者和主题日期。红色框突出显示主题数据以标识网站。</a></p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-9.jpeg" alt="The screenshot shows how to find certificate issuer and subject date for HTTPS traffic, using www.paloaltonetworks.com as an example. A red box highlights the subject data to identify the website. "></p>
<p>图8.从HTTPS流量到<a href="http://www.paloaltonetworks.com的证书数据。" target="_blank" rel="noopener">www.paloaltonetworks.com的证书数据。</a><br>但是，在设置Web服务器时，管理员可以生成自签名证书。自签名证书是本地生成的，不由任何证书颁发机构颁发。在现代浏览器（例如Firefox）中查看时，来自此类服务器的HTTPS流量通常会生成错误消息，如图9所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-10.jpeg" alt="HTTPS traffic from self-signed certificates often generates error messages when viewed in modern browsers, such as this warning from Firefox, which states, &quot;Warning: Potential Security Risk Ahead.&quot; "></p>
<p>当在现代浏览器中查看时，来自自签名证书的HTTPS通信通常会生成错误消息，例如来自Firefox的警告，该警告指出“警告：潜在的安全隐患”。<br>图9.尝试从使用自签名证书的网站查看页面时，Firefox出现错误。<br>恶意软件开发人员通常将自签名证书用于其C2服务器。为什么？因为自签名证书是快速，容易和免费创建的。此外，恶意软件的HTTPS C2流量不涉及Web浏览器，因此加密的流量可以正常工作而不会出现任何错误或警告。</p>
<p>生成自签名证书涉及为以下字段输入值（其中一些通常留为空白）：</p>
<p>国家名称（2个字母代码）。<br>州或省名称。<br>地区名称（通常是城市名称）。<br>机构名称。<br>组织单位名称。<br>通用名称（例如，标准主机名）。<br>电子邮件地址。<br>这些字段用于标识网站的主题数据，但是相同的字段和值也用于颁发者，因为证书是在Web服务器本身上本地生成的。</p>
<p>恶意软件作者经常在这些字段中使用随机，默认或伪造的值作为自签名证书。例如，Trickbot的HTTPS C2流量通常将example.com用于“通用名称”字段。来自最近的IcedID恶意软件感染的HTTPS C2流量在其证书颁发者字段中使用了以下值：</p>
<p>国家/地区名称：AU<br>州或省名称：Some-State<br>组织名称：Internet Widgits Pty Ltd<br>通用名称：localhost<br>与其他恶意软件家族相比，<strong>Dridex HTTPS C2流量的证书颁发者数据中的模式有些独特。它们可能是识别Dridex感染的关键。</strong></p>
<h2 id="Pcaps-of-Dridex感染活性"><a href="#Pcaps-of-Dridex感染活性" class="headerlink" title="Pcaps of Dridex感染活性"></a>Pcaps of Dridex感染活性</h2><p>该GitHub存储库中提供了五个密码保护的ZIP存档，其中包含近期Dridex网络流量的pcaps。进入GitHub页面后，单击每个ZIP归档条目，然后下载它们，如图10和11所示。</p>
<p>这显示了如何从GitHub存储库中下载本教程使用的ZIP存档pan-unit42 / wireshark-tutorial-Dridex-traffic<br>图10. GitHub存储库，其中包含指向本教程的ZIP存档的链接。<br>屏幕截图显示了从GitHub存储库下载存储此Wireshark教程文件的zip存档2020-06-03-Dridex-infection-traffic-pcap.zip的示例<br>图11.下载本教程的ZIP归档文件之一。<br>使用感染的作为密码从这些ZIP存档中提取pcap。这将产生五个pcap文件：</p>
<p>2020-06-03-Dridex-infection-traffic.pcap<br>2020-09-24-Dridex-infection-traffic.pcap<br>2020-09-29-Dridex-infection-traffic.pcap<br>2020-10-05-Dridex-infection-traffic.pcap<br>2020-10-07-Dridex-infection-traffic.pcap</p>
<h2 id="范例一：2020-06-03-Dridex-infection-traffic-pcap"><a href="#范例一：2020-06-03-Dridex-infection-traffic-pcap" class="headerlink" title="范例一：2020-06-03-Dridex-infection-traffic.pcap"></a>范例一：2020-06-03-Dridex-infection-traffic.pcap</h2><p>在Wireshark中打开2020-06-03-Dridex-infection-traffic.pcap，并使用一个基本的Web过滤器，如上一本有关Wireshark过滤器的教程所述。我们针对Wireshark 3.x的基本过滤器是：</p>
<p>（http.request或tls.handshake.type eq 1）和！（ssdp）</p>
<p>Dridex感染流量包括两个部分ts：</p>
<p>初始感染活动。<br>感染后C2流量。<br>当受害者从电子邮件链接下载恶意文件时，就会发生初始感染活动。初始感染活动还包括恶意文件加载Dridex的安装程序。在某些情况下，您可能没有初始下载，因为恶意文件是电子邮件的附件。在其他情况下，您可能看不到Dridex安装程序已加载，因为初始文件本身就是安装程序。在许多情况下，此活动是通过HTTPS进行的，因此我们看不到任何URL，而只是域名。</p>
<p>感染后活动是在受害者被感染后发生的HTTPS C2通信。成功感染Dridex期间，总是会发生这种情况。此C2通信直接与IP地址进行通信，因此没有与之关联的域名。它还具有异常的证书颁发者数据，如下所述。</p>
<p>图12显示了使用我们的基本Web过滤器在Wireshark中打开的第一个示例。没有域名的行是Dridex HTTPS C2通信。</p>
<p>此屏幕快照显示了在Wireshark中过滤的Dridex感染流量。该屏幕标记为2020-06-03-Dridex-infection-traffic.pcap</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-13.jpeg" alt="This screenshot shows Dridex infection traffic, filtered in Wireshark. The screen is labeled 2020-06-03-Dridex-infection-traffic.pcap">图12.使用我们的基本Web过滤器在Wireshark中过滤的第一个pcap的流量。</p>
<p>图12中显示的第一个pcap显示了直接到IP地址而不是域名的以下流量。这很可能是Dridex HTTPS C2流量：</p>
<ul>
<li>185.86.148[.]68 over TCP port 443</li>
<li>212.95.153[.]36 over TCP port 453</li>
</ul>
<p>使用我们的基本Web过滤器看到的其他域是使用以microsoft.com，office.net或windows.com等著名名称结尾的域的系统流量。唯一的例外是到达truepenesonga[.]com的HTTPS流量，该流量接近pcap在世界标准时间19:38:18的开始。这可能是Dridex安装程序。快速的Google搜索表明truepenesonga[.]com与恶意软件相关联。</p>
<p>关注感染后Dridex C2流量。在Wireshark中使用以下过滤器来查看证书颁发者数据，以了解这两个IP地址上的HTTPS流量：</p>
<p>tls.handshake.type eq 11 and (ip.addr eq 185.86.148.68 or ip.addr eq 212.95.153.36)</p>
<p>应用过滤器后，在Wireshark列显示中选择第一帧，然后转到帧详细信息面板并展开值，如图13所示，直到找到以术语RDNSequence项目开头的行的列表为止。 。</p>
<p>屏幕快照突出显示了可用于查找Dridex HTTPS C2通信的证书颁发者数据的关键点。红色箭头特别指出传输层安全性，证书，握手协议，签名证书，颁发者和rdnSequence。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-14.jpeg" alt="The screenshot highlights key spots that can be used for finding certificate issuer data for Dridex HTTPS C2 traffic. Red arrows particularly point out Transport layer security, certificate, handshake protocol, signed certfiicate, issuer and rdnSequence. "></p>
<p>图13.查找Dridex HTTPS C2流量的证书颁发者数据。<br>请注意用于185.86.148[.]68的HTTPS流量的RDNSequence项目及其值：</p>
<ul>
<li>id-at-countryName=Vu</li>
<li>id-at-stateOrProvinceName=Uererarnk4</li>
<li>id-at-localityName=Port Vila</li>
<li>id-at-organizationName=Whensean Imegdtc SICAV</li>
<li>id-at-organizationUnitName=6Tbuthinalq</li>
<li>id-at-commonName=1andfhtittbly.fan</li>
</ul>
<p>Dridex证书颁发者字段通常包含随机字符串，有时会插入一两个数字。但是，国家/地区名称和城市或地区的值通常会匹配。在上面的示例中，Vu是瓦努阿图的2个字母的国家代码，而Vila端口是瓦努阿图的首都。</p>
<p>对到212.95.153[.]36的HTTPS通信执行相同的操作，您应该找到：</p>
<ul>
<li>id-at-countryName=AO</li>
<li>id-at-localityName=Luanda</li>
<li>id-at-organizationName=Msorest KGaA</li>
<li>id-at-organizationUnitName=aghat@yongd</li>
<li>id-at-commonName=arashrinwearc.Ourontizes.ly</li>
</ul>
<p>我们发现当地的罗安达是安哥拉的首都，其国家代码为AO。但是其他字段似乎具有随机值。这种类型的证书颁发者数据是Dridex C2流量的有力指标。</p>
<h2 id="示例二：2020-09-24-Dridex-infection-traffic-pcap"><a href="#示例二：2020-09-24-Dridex-infection-traffic-pcap" class="headerlink" title="示例二：2020-09-24-Dridex-infection-traffic.pcap"></a>示例二：2020-09-24-Dridex-infection-traffic.pcap</h2><p>在Wireshark中打开2020-09-24-Dridex-infection-traffic.pcap并使用基本的Web过滤器，如图14所示。</p>
<p>此屏幕快照显示了在Wireshark中过滤的Dridex感染流量。该屏幕标记为2020-09-24-Dridex-infection-traffic.pcap</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-15.jpeg" alt="This screenshot shows Dridex infection traffic, filtered in Wireshark. The screen is labeled 2020-09-24-Dridex-infection-traffic.pcap"></p>
<p>图14.使用基本的Web过滤器，在Wireshark中过滤的第二个pcap的流量。<br>请注意，前三行是未加密的HTTP GET请求。这是来自图3前面所示电子邮件的链接，它为感染链返回了一个ZIP存档，如图7所示。</p>
<p>可以遵循HTTP流（而非TCP流）。向下滚动以查看返回了一些脚本，如图15和16所示。<img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-16.jpeg" alt="The HTTP stream (not the TCP stream) can be followed. The screenshot indicates how to find that option in Wireshark. "></p>
<p>图15.在第一个HTTP GET请求的HTTP流之后。<br>当遵循HTTP流进行Dridex感染流量时，向下滚动以查看从第一个HTTP GET请求返回的脚本。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-17.jpeg" alt="When following the HTTP Stream for the Dridex infection traffic, scroll down to view the script returned from the first HTTP GET request. "></p>
<p>图16.向下滚动以查看从该HTTP GET请求返回的脚本。<br>对adv.epostoday[.]uk的所有三个HTTP GET请求都在同一TCP流中。在最后一个HTTP GET请求f之前向下滚动到末尾或favicon.ico。您会发现一个长长的ASCII字符字符串的结尾，该字符串转换为blob并作为Ref_Sep24-2020.zip发送给受害者，如图17所示。</p>
<p>红色箭头指示Ref_Sept24-2020.zip，这是鼓励受害者从浏览器保存的ZIP存档。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-18.jpeg" alt="A red arrow indicates Ref_Sept24-2020.zip, the ZIP archive that the victim will be encouraged to save from the browser. "></p>
<p>图17.脚本旨在将ZIP存档呈现给受害者，以从浏览器保存。<br>可以使用“导出HTTP对象”功能来导出这些脚本，如图18所示。</p>
<p>使用“导出HTTP对象”功能，可以保存从以app.php结尾的URL返回的脚本。红色箭头指示要选择的选项。<br>图18.保存从以app.php结尾的URL返回的脚本。<br>再次关注感染后Dridex C2流量。在Wireshark中使用以下过滤器来查看两个IP地址上的HTTPS通信的证书颁发者数据，而HTTPS通信中没有域名：</p>
<p>tls.handshake.type eq 11 and (ip.addr eq 151.236.219.181 or ip.addr eq 62.98.109.30)</p>
<p>应用过滤器后，选择第一个框架并转到框架详细信息部分。查找第一个pcap中以RDNSequence项开头的行的列表。图19显示了如何在我们的第二个pcap中到达151.236.219[.]181。</p>
<p>屏幕快照突出显示了可用于查找Dridex HTTPS C2通信的证书颁发者数据的关键点。红色箭头特别指出传输层安全性，证书，握手协议，签名证书，颁发者和rdnSequence。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-20.jpeg" alt="The screenshot highlights key spots that can be used for finding certificate issuer data for Dridex HTTPS C2 traffic. Red arrows particularly point out Transport layer security, certificate, handshake protocol, signed certfiicate, issuer and rdnSequence. "></p>
<p>图19.在第二个pcap中查找Dridex HTTPS C2流量的证书颁发者数据。<br>证书发行者数据与第一个示例的数据相似。检查两个IP地址的证书颁发者数据，然后找到下面列出的数据。</p>
<p>151.236.219[.]181上Dridex HTTPS C2通信的证书颁发者数据：</p>
<ul>
<li>id-at-countryName=IL</li>
<li>id-at-stateOrProvinceName=Anourd Thiolaved Thersile5 Fteda8</li>
<li>id-at-LocalityName=Tel Aviv</li>
<li>id-at-organizationName=Wemadd Hixchac GmBH</li>
<li>id-at-organizationUnitName=moasn@emanc</li>
<li>id-at-commonName=heardbellith.Icanwepeh.nagoya</li>
</ul>
<ul>
<li>id-at-countryName=SS</li>
<li>id-at-LocalityName=Khartoum</li>
<li>id-at-organizationName=Hedanpr S.p.a.</li>
<li>id-at-commonName=psprponounst.aquarelle</li>
</ul>
<p>在这两种情况下，位置均与国家/地区名称匹配，但是其他字段似乎是随机字符串。这与我们第一个pcap中的Dridex HTTPS C2流量相同。</p>
<h2 id="示例三：2020-09-29-Dridex-infection-traffic-pcap"><a href="#示例三：2020-09-29-Dridex-infection-traffic-pcap" class="headerlink" title="示例三：2020-09-29-Dridex-infection-traffic.pcap"></a>示例三：2020-09-29-Dridex-infection-traffic.pcap</h2><p>在Wireshark中打开2020-09-29-Dridex-infection-traffic.pcap并使用基本的Web过滤器，如图20所示。</p>
<p>此屏幕快照显示了在Wireshark中过滤的Dridex感染流量。该屏幕标记为2020-09-29-Dridex-infection-traffic.pcap</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-21.jpeg" alt="This screenshot shows Dridex infection traffic, filtered in Wireshark. The screen is labeled 2020-09-29-Dridex-infection-traffic.pcap"></p>
<p>图20.使用我们的基本Web过滤器在Wireshark中过滤的第三个pcap的流量。<br>检查这些域，发现有三个使用HTTPS流量的非Microsoft域可能与初始感染活动有关：</p>
<p>dsimportaciones[.]com<br>murfreesboro.fairwayconcierge[.]com<br>ryner.net[.]au<br>由于这些是特定于URL的，并且未显示其内容，因此请专注于感染后Dridex C2流量。在Wireshark中使用以下过滤器来查看两个IP地址上的HTTPS通信的证书颁发者数据，而HTTPS通信中没有域名：</p>
<p>tls.handshake.type eq 11 and (ip.addr eq 67.79.105.174 or ip.addr eq 144.202.31.138)</p>
<p>应用过滤器后，选择第一个框架，转到“框架详细信息”部分，并查找以术语RDNSequence项开头的行的列表，如在前两个示例中所做的那样。图21显示了如何在67.79.105[.]174的第三个pcap中到达那里。</p>
<p>屏幕快照突出显示了可用于查找Dridex HTTPS C2通信的证书颁发者数据的关键点。红色箭头特别指出传输层安全性，证书，握手协议，签名证书，颁发者和rdnSequence。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-22.jpeg" alt="The screenshot highlights key spots that can be used for finding certificate issuer data for Dridex HTTPS C2 traffic. Red arrows particularly point out Transport layer security, certificate, handshake protocol, signed certfiicate, issuer and rdnSequence. "></p>
<p>图21.在第三个pcap中查找Dridex HTTPS C2流量的证书颁发者数据。<br>证书颁发者数据遵循与前两个示例相同的模式。检查两个IP地址的发行方数据，以查找下面列出的数据。</p>
<p>Dridex HTTPS C2通信在67.79.105[.]174上的证书颁发者数据：</p>
<ul>
<li>id-at-countryName=MN</li>
<li>id-at-stateOrProvinceName=Listth Thearere8 berponedt tithsalet</li>
<li>id-at-LocalityName=Ulaanbaatar</li>
<li>id-at-organizationName=Massol SE</li>
<li>id-at-commonName=Atid7brere.Speso_misetr.stada</li>
</ul>
<p>144.202.31[.]138上Dridex HTTPS C2通信的证书颁发者数据：</p>
<ul>
<li>id-at-countryName=SS</li>
<li>id-at-LocalityName=Khartoum</li>
<li>id-at-organizationName=Hedanpr S.p.a.</li>
<li>id-at-commonName=psprponounst.aquarelle</li>
</ul>
<p>值得注意的是，从2020-09-29开始的第三个示例中的144.202.31[.]138的证书颁发者数据与从2020-09-24开始的第二个示例中的62.98.109[.]30的证书颁发者数据相同。</p>
<h2 id="示例四：2020-10-05-Dridex-infection-traffic-pcap"><a href="#示例四：2020-10-05-Dridex-infection-traffic-pcap" class="headerlink" title="示例四：2020-10-05-Dridex-infection-traffic.pcap"></a>示例四：2020-10-05-Dridex-infection-traffic.pcap</h2><p>在Wireshark中打开2020-10-05-Dridex-infection-traffic.pcap并使用基本的Web过滤器，如图Fi中所示固尔22。</p>
<p>此屏幕快照显示了在Wireshark中过滤的Dridex感染流量。屏幕标记为2020-10-05-Dridex-infection-traffic.pcap</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-23.jpeg" alt="This screenshot shows Dridex infection traffic, filtered in Wireshark. The screen is labeled 2020-10-05-Dridex-infection-traffic.pcap"></p>
<p>图22.使用基本的Web过滤器在Wireshark中过滤的第四个pcap的流量。<br>检查这些域，有一个使用HTTPS流量的非Microsoft域可能与初始感染活动有关：</p>
<p>vardhmanproducts[.]com<br>再次，重点将放在感染后的Dridex C2流量上。在Wireshark中使用以下过滤器来查看两个IP地址上的HTTPS通信的证书颁发者数据，而HTTPS通信中没有域名：</p>
<p>tls.handshake.type eq 11 and (ip.addr eq 85.114.134.25 or ip.addr eq 85.211.162.44)</p>
<p>应用过滤器后，选择第一个框架，转到“框架详细信息”部分，然后按照前三个示例中的方法处理以术语RDNSequence项目开头的行的列表。</p>
<p>证书颁发者数据遵循与前三个示例相同的模式。检查两个IP地址的颁发者数据，您应该找到下面列出的数据。</p>
<p>85.114.134[.]25上Dridex HTTPS C2流量的证书颁发者数据：</p>
<ul>
<li>id-at-countryName=NZ</li>
<li>id-at-stateOrProvinceName=Cepli thade0 ithentha temsorer</li>
<li>id-at-LocalityName=Wellington</li>
<li>id-at-organizationName=Lling Lovisq NL</li>
<li>id-at-organizationalUnitName=Punddtln</li>
<li>id-at-commonName=Onshthonese.vyrda-npeces.post</li>
</ul>
<p>85.211.162[.]44上Dridex HTTPS C2流量的证书颁发者数据：</p>
<ul>
<li>id-at-countryName=MY</li>
<li>id-at-LocalityName=Kuala Lumpur</li>
<li>id-at-organizationName=Ointavi Tagate Unltd.</li>
<li>id-at-commonName=Ateei7thapom.statonrc.loan</li>
</ul>
<h2 id="示例五：2020-10-07-Dridex-infection-traffic-pcap"><a href="#示例五：2020-10-07-Dridex-infection-traffic-pcap" class="headerlink" title="示例五：2020-10-07-Dridex-infection-traffic.pcap"></a>示例五：2020-10-07-Dridex-infection-traffic.pcap</h2><p>在Wireshark中打开2020-10-07-Dridex-infection-traffic.pcap并使用基本的Web过滤器，如图23所示。</p>
<p>此屏幕快照显示了在Wireshark中过滤的Dridex感染流量。该屏幕标记为2020-10-07-Dridex-infection-traffic.pcap</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/10/word-image-24.jpeg" alt="This screenshot shows Dridex infection traffic, filtered in Wireshark. The screen is labeled 2020-10-07-Dridex-infection-traffic.pcap"></p>
<p>图23.使用基本的Web过滤器在Wireshark中过滤的第五个pcap的流量。</p>
<p>检查这些域，有一个使用HTTPS流量的非Microsoft域可能与初始感染活动有关：</p>
<p>newmg532.wordswideweb[.]com<br>检查感染后的Dridex C2流量。在Wireshark中使用以下过滤器来查看两个IP地址上的HTTPS通信的证书颁发者数据，而HTTPS通信中没有域名：</p>
<p>tls.handshake.type eq 11 and (ip.addr eq 177.87.70.3 or ip.addr eq 188.250.8.142)</p>
<p>应用过滤器后，选择第一个框架，转到“框架详细信息”部分，然后按照我们的前四个示例中的方法处理以术语RDNSequence项目开头的行的列表。</p>
<p>证书颁发者数据遵循与我们前四个示例相同的模式。检查两个IP地址的颁发者数据，并找到下面列出的数据。</p>
<p>在177.87.70[.]3上Dridex HTTPS C2流量的证书颁发者数据：</p>
<ul>
<li>id-at-countryName=BS</li>
<li>id-at-stateOrProvinceName=Sshopedts Inccofrew</li>
<li>id-at-LocalityName=Nassau</li>
<li>id-at-organizationName=Mesureder S.p.a.</li>
<li>id-at-commonName=avothelyop.thedai9neasysb.author</li>
</ul>
<p>188.250.8[.]142上Dridex HTTPS C2通信的证书颁发者数据：</p>
<ul>
<li>id-at-countryName=UA</li>
<li>id-at-stateOrProvinceName=avandi0</li>
<li>id-at-LocalityName=Kiev</li>
<li>id-at-organizationName=Icccodiso Icloneedb Oyj</li>
<li>id-at-organizationalUnitName=4Zenyfea</li>
<li>id-at-commonName=rebydustat.tci</li>
</ul>
<p>这五个示例应该很好地说明Dridex HTTPS C2通信的证书颁发者数据是什么样的。这些模式不同于许多其他恶意软件家族，但它们与HTTPS C2 Qakbot网络流量中的证书颁发者数据有些相似。</p>
<p>但是，对于Qakbot，stateOrProvinceName始终是两个字母的值，而LocalityName由随机字符组成。</p>
<p>使用Dridex，stateOrProvinceName由随机字符组成，而LocalityName是用于countryName的任何国家的首都。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本教程回顾了如何从具有Dridex网络流量的pcap中识别Dridex活动。我们回顾了最近发现的五个Dridex感染事件，并从感染后C2流量中发现了证书颁发者数据的相似性。证书颁发者数据是识别Dridex感染的关键，因为这些模式对于Dridex而言似乎是唯一的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E6%A3%80%E6%9F%A5Emotet%E6%84%9F%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E6%A3%80%E6%9F%A5Emotet%E6%84%9F%E6%9F%93/" itemprop="url">Wireshark教程：检查Emotet感染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-03T19:41:30+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="检查Emotet感染"><a href="#检查Emotet感染" class="headerlink" title="检查Emotet感染"></a>检查Emotet感染</h1><p>本教程适用于调查可疑网络活动并查看数据包捕获（pcaps）的安全专业人员。必须熟悉Wireshark才能理解本教程，该教程侧重于Wireshark版本3.x。</p>
<p>Emotet是一名信息窃取者，于2014年首次被报告为银行恶意软件。从那以后，它就不断发展，并具有其他功能，例如：dropper，可以分发其他恶意软件家族，如Gootkit，IcedID，Qakbot和Trickbot。</p>
<p>今天的Wireshark教程回顾了最近的Emotet活动，并提供了一些有关基于流量分析来识别此恶意软件的有用提示。</p>
<p>您将需要使用包含本教程使用的pcap的ZIP存档访问GitHub存储库。</p>
<p>警告：本教程使用的某些pcap中包含基于Windows的恶意软件。如果使用Windows计算机，则存在感染的风险。如果可能，我们建议您在非Windows环境（例如BSD，Linux或macOS）中查看这些pcap。</p>
<h2 id="Emotet感染的事件链"><a href="#Emotet感染的事件链" class="headerlink" title="Emotet感染的事件链"></a>Emotet感染的事件链</h2><p>要了解由Emotet引起的网络流量，您必须首先了解导致感染的事件链。 Emotet通常通过恶意垃圾邮件（malspam）电子邮件进行分发。 Emotet感染链中的关键步骤是一个Microsoft Word文档，其中包含旨在感染易受攻击的Windows主机的宏。</p>
<p>所示的Word文档被用于在2021年1月引起Emotet感染。请注意屏幕快照中的消息：该文档受保护。预览不适用于受保护的文档。您必须按下“启用编辑”和“启用内容”按钮才能预览此文档。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-30.jpeg" alt="This Word document shown was used to cause an Emotet infection in January 2021. Note the message in the screenshot: This document is protected. Previewing is not available for protected documents. You have to press &quot;ENABLE EDITING&quot; and &quot;ENABLE CONTENT&quot; buttons to preview this document. "></p>
<p>图1. 2021年1月用于引起Emotet感染的Word文档的屏幕截图。<br>传播垃圾邮件Emotet使用不同的技术来分发这些Word文档。</p>
<p>垃圾邮件可能包含附加的Microsoft Word文档，或者具有包含Word文档的附加ZIP存档。在最近几个月中，我们看到了几个示例，其中这些ZIP存档受密码保护。某些分发Emotet的电子邮件没有任何附件。而是，它们包含下载Word文档的链接。</p>
<p>在过去的几年中，垃圾邮件推动Emotet还使用带有嵌入式链接的PDF附件来提供这些Emotet Word文档。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-31.jpeg" alt="Distribution paths for Emotet Word document: 1) malspam with attachment to Word doc; 2) malspam with attachment to ZIP archive to Word doc; 3) malspam with link to web traffic to download Word doc to Word doc; 4) malspam with attachment to PDF file to web traffic to download Word doc to Word doc"></p>
<p>图2说明了这四种分配技术。</p>
<blockquote>
<p>Emotet Word文档的分发路径：</p>
<p>1）带有Word doc附件的垃圾邮件；</p>
<p> 2）垃圾邮件，并将ZIP存档附加到Word doc； </p>
<p>3）带有网络流量链接的垃圾邮件，可下载Word doc；</p>
<p> 4）带有PDF文件附件的垃圾邮件到网络访问量中，以下载Word doc</p>
</blockquote>
<p>图2. Emotet Word文档的各种分发路径。<br>交付Word文档后，如果受害者打开文档并在易受攻击的Windows主机上启用了宏，则该主机感染了Emotet。</p>
<p>从流量的角度来看，我们看到从Emotet Word文档到Emotet感染的以下步骤：</p>
<p>Web流量检索初始二进制文件。<br>通过HTTP的编码/加密命令和控制（C2）通信。<br>如果Emotet丢弃了后续恶意软件，则额外的感染流量。<br>如果Emotet使用受感染的主机作为垃圾邮件程序，则SMTP流量。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-32.jpeg" alt="Flowchart for an Emotet infection: Word doc to enable macros to web traffic for initial binary to initial binary. From there, encoded C2 traffic over HTTP, which is a hub in the flowchart that can lead to follow-up malware, spambot activity, data exfiltration and updating the binary. ">图3显示了我们在Emotet感染期间可能发现的网络活动的流程图。</p>
<p>Emotet感染的流程图：Word doc使宏能够将网络流量从初始二进制文件转换为初始二进制文件。从那里开始，通过HTTP进行编码的C2流量，这是流程图中的中心，可导致后续恶意软件，垃圾邮件活动，数据泄露和更新二进制文件。</p>
<p>自2020年12月21日以来，Emotet的初始二进制文件一直是Windows DLL文件。以前，此二进制文件是Windows EXE文件。</p>
<p>Emotet C2通信量包含通过HTTP发送的编码或其他加密数据。此C2活动可以使用与HTTP流量关联的标准或非标准TCP端口。此C2活动还包括数据泄漏和更新初始Emotet二进制文件的流量。</p>
<p>由于Emotet还是一个恶意软件删除程序，因此受害者可能会感染其他恶意软件。分析来自受Emotet感染的主机的流量时，分析师应搜索其他恶意软件的流量。</p>
<p>最终，受Emotet感染的主机也可能成为垃圾邮件程序，它通过与SMTP相关的TCP端口（如TCP端口25、465和587）生成大量流量。</p>
<h2 id="Pcaps的Emotet变化感染活动"><a href="#Pcaps的Emotet变化感染活动" class="headerlink" title="Pcaps的Emotet变化感染活动"></a>Pcaps的Emotet变化感染活动</h2><p>五个包含pca的受密码保护的ZIP归档文件在此GitHub存储库<a href="https://github.com/pan-unit42/wireshark-tutorial-Emotet-traffic中提供了有关最近Emotet感染流量的一些信息。进入GitHub页面后，单击每个ZIP归档条目并下载它们。" target="_blank" rel="noopener">https://github.com/pan-unit42/wireshark-tutorial-Emotet-traffic中提供了有关最近Emotet感染流量的一些信息。进入GitHub页面后，单击每个ZIP归档条目并下载它们。</a></p>
<ul>
<li>Example-1-2021-01-06-Emotet-infection.pcap</li>
<li>Example-2-2021-01-05-Emotet-with-spambot-traffic-part-1.pcap</li>
<li>Example-3-2021-01-05-Emotet-with-spambot-traffic-part-2.pcap</li>
<li>Example-4-2021-01-05-Emotet-infection-with-Trickbot.pcap</li>
<li>Example-5-2020-08-18-Emotet-infection-with-Qakbot.pcap</li>
</ul>
<p>在Wireshark中打开Example-1-2021-01-06-Emotet-infection.pcap，并使用基本的Web过滤器，如我们先前有关Wireshark过滤器的教程中所述。 Wireshark 3.x的basic</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-35.jpeg" alt="Figure 6. Our first pcap in this tutorial filtered in Wireshark."></p>
<p>图6.本教程中的第一个pcap在Wireshark中进行了过滤。<br>如图6所示，前五个HTTP GET请求代表用于检索初始Emotet DLL的四个URL。流量为：</p>
<ul>
<li>hangarlastik[.]com GET /cgi-bin/Ui4n/</li>
<li>hangarlastik[.]com GET /cgi-sys/suspendedpage.cgi</li>
<li>padreescapes[.]com GET /blog/0I/</li>
<li>sarture[.]com GET /wp-includes/JD8/</li>
<li>seo.udaipurkart[.]com GET /rx-5700-6hnr7/Sgms/</li>
</ul>
<p>前两个URL指示hangarlastik[.]com不再具有它所托管的Emotet DLL文件。跟踪每个请求的TCP流，以查看对每个HTTP GET请求的答复。</p>
<p>查看HTTP响应的一种更简单的方法是更新Wireshark基本Web过滤器以包含HTTP响应：</p>
<p>(http.request <strong>or http.response</strong> or tls.handshake.type eq 1) and !(ssdp)</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-36.jpeg" alt="Figure 7. Adding HTTP responses to the Wireshark display filter."></p>
<p>这将在Info列中显示HTTP响应。</p>
<p>图7.将HTTP响应添加到Wireshark显示过滤器。</p>
<p>现在，我们对Word宏尝试检索Emotet DLL时发生的情况有了更清晰的了解：</p>
<ul>
<li>hangarlastik[.]com GET /cgi-bin/Ui4n/</li>
<li>HTTP/1.1 302 Found</li>
<li>hangarlastik[.]com GET /cgi-sys/suspendedpage.cgi</li>
<li>HTTP/1.1 200 OK</li>
<li>padreescapes[.]com GET /blog/0I/</li>
<li>HTTP/1.1 401 Unauthorized</li>
<li>sarture[.]com GET /wp-includes/JD8/</li>
<li>HTTP/1.1 403 Forbidden</li>
<li>seo.udaipurkart[.]com GET /rx-5700-6hnr7/Sgms/</li>
</ul>
<p>唯一可以接受的200回复是来自hangarlastik[.]com的suspendedpage.cgi。</p>
<p>到seo.udaipurkart[.]com的HTTP GET请求未显示响应，因此请遵循此请求的TCP流。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-37.jpeg" alt="Figure 8. Following TCP stream for the HTTP request to seo.udaipurkart[.]com."></p>
<p>图8.针对seo.udaipurkart[.]com的HTTP请求的以下TCP流。<br>TCP流显示指示符，指示seo.udaipurkart[.]com返回了Windows DLL文件，如图9所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-38.jpeg" alt="Figure 9. Indicators of a DLL file returned from seo.udaipurkart[.]com.">图9.从seo.udaipurkart[.]com返回的DLL文件的指示器。</p>
<p>通过使用菜单路径从pcap导出此DLL：File-&gt; Export Objects-&gt; HTTP，如图10所示。与往常一样，我们建议您不要在Windows环境中导出此文件，因为DLL是Windows恶意软件。</p>
<p>Emotet C2流量是使用HTTP POST请求发送的编码数据。您可以使用以下过滤器在Wireshark中轻松找到这些请求：</p>
<p>http.request.method eq POST</p>
<p>结果如图11所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-40.jpeg" alt="Figure 11. Filtering for HTTP POST requests in our first pcap."></p>
<p>图11.在我们的第一个pcap中过滤HTTP POST请求。</p>
<p>在我们的第一个pcap中，Emotet C2流量由HTTP POST请求组成，这些请求包括：</p>
<ul>
<li>5.2.136[.]90 over TCP port 80</li>
<li>167.71.4[.]0 over TCP port 8080</li>
</ul>
<p>Emotet为其C2流量生成两种类型的HTTP POST请求。第一种POST请求以HTTP / 1.1结尾。第二种POST请求以HTTP/1.1 (application/x-www-form-urlencoded)结尾。</p>
<p>按照针对初始HTTP请求的TCP流到达UTC 5.2.136 [.] 90（UTC时间16:42:34），以查看第一种C2 POST请求的示例，如图12所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-41.jpeg" alt="Figure 12. The first type of HTTP POST request for Emotet C2 traffic."></p>
<p>图12.针对Emotet C2流量的第一种HTTP POST请求。<br>图12显示了此POST请求发送了大约6 K数据，似乎是已编码或已加密的二进制文件。向下滚动到HTTP响应以查看从服务器返回的编码数据。图13显示了此编码数据的开始。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-42.jpeg" alt="Figure 13. Encoded data returned from the server in response to the HTTP POST request."><br>图13.从服务器返回的响应HTTP POST请求的编码数据。<br>这种类型的编码或加密数据是Emotet僵尸网络服务器如何与受感染的Windows主机交换数据的方式。这也是Emotet用于更新Emotet DLL并删除后续恶意软件的渠道。</p>
<p>针对Emotet C2流量的第二种HTTP POST请求看起来与第一种明显不同。在Wireshark中使用以下过滤器可以轻松找到第二种HTTP POST请求：</p>
<p>编码形式</p>
<p>这应该通过TCP端口8080将两个HTTP POST请求返回到167.71.4 [.] 0，如图14所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-43.jpeg" alt="Figure 14. Filtering for the second type of HTTP POST request in Emotet C2 traffic."></p>
<p>图14.过滤Emotet C2通信中的第二种HTTP POST请求。<br>按照这两个HTTP POST请求中第一个的UTC的TCP流进行操作：16：58：43 UTC。查看流量。结果如图15所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-44.jpeg" alt="Figure 15. TCP stream for the second type of HTTP POST request in Emotet C2 traffic."></p>
<p>图15. Emotet C2通信中第二种HTTP POST请求的TCP流。<br>如图15所示，POST请求中发送的某些数据被编码为具有某些URL编码的base64字符串。例如，％2B表示+，％2F表示/，％3D表示=。</p>
<p>来自服务器的响应所发送的数据已被编码或以其他方式加密。</p>
<p>我们的第一个pcap没有后续的恶意软件或其他重要活动。</p>
<p>唯一的其他活动是通过TCP端口443重复尝试连接到46.101.230 [.] 194。您可以通过过滤作为重传的TCP SYN段来轻松地发现此活动。使用以下Wireshark过滤器：</p>
<p>tcp.analysis.retransmission and tcp.flags eq 0x0002</p>
<p>结果如图16所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-45.jpeg" alt="Figure 16. Filtering on retransmissions of TCP SYN segments in Wireshark."></p>
<p>图16.在Wireshark中对TCP SYN段的重传进行过滤。</p>
<p>在46.101.230 [.] 194上进行的Internet搜索应该显示此IP地址已用于Emotet C2活动。</p>
<p>pcap中的剩余流量是由Microsoft Windows 10主机生成的系统流量。</p>
<p>在下一个pcap中，我们将检查带有垃圾邮件机器人活动的Emotet感染。</p>
<h2 id="示例2：带有垃圾邮件流量的Emotet，第1部分"><a href="#示例2：带有垃圾邮件流量的Emotet，第1部分" class="headerlink" title="示例2：带有垃圾邮件流量的Emotet，第1部分"></a>示例2：带有垃圾邮件流量的Emotet，第1部分</h2><p>在Wireshark中打开Example-2-2021-01-05-Emotet-with-spambot-traffic-part-1.pcap，并使用基本的Web过滤器，如图17所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-46.jpeg" alt="Figure 17. Traffic from the second pcap filtered in Wireshark using our basic web filter."></p>
<p>图17.使用我们的基本Web过滤器在Wireshark中过滤的第二个pcap的流量。</p>
<p>与第一个示例类似，我们在Emotet C2流量之前收到了一些HTTP GET请求。这些GET请求是尝试通过网络流量下载初始Emotet DLL的尝试。列显示的第一帧显示到obob [.] tv的HTTPS流量，这可能是对原始Emotet DLL的Web请求，因为据报此域在2021年1月5日（与该日期相同）托管Emotet二进制文件 pcap中的流量。</p>
<p>按照TCP流对miprimercamino [.] com的HTTP GET请求进行确认，以确认它返回了Emotet DLL。您应该从我们的第一个pcap中看到类似于图9的指示器。我们可以导出从miprimercamino [.] com返回的Emotet DLL，如图18所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-47.jpeg" alt="Figure 18. Exporting the Emotet DLL from the pcap."></p>
<p>图18.从pcap导出Emotet DLL。<br>从第二个pcap中提取的DLL的SHA256哈希为：</p>
<p>963b00584d8d63ea84585f7457e6ddcac9eda54428a432f388a1ffee21137316</p>
<p>同样，我们发现针对Emotet C2流量的两种HTTP POST请求。要针对每种Emotet C2 HTTP POST请求进行过滤，请使用以下Wireshark过滤器：</p>
<p>第一种类型：http.request method eq POST and !(urlencoded-form)<br>第二种：urlencoded-form<br>跟踪这些过滤器返回的HTTP POST请求的TCP流，并确认它们遵循在我们的第一个pcap中看到的相同模式。</p>
<p>在查看了来自此pcap的一些Emotet C2流量示例之后，我们继续进行垃圾邮件机器人活动。</p>
<p>在此示例中，我们被感染的主机变成了垃圾邮件机器人，因此我们也有SMTP通信。 spambot SMTP流量已加密，但是我们可以使用基本的Web过滤器并向下滚动列显示轻松找到它。</p>
<p>在20:06:20 UTC，pcap开始显示到与SMTP电子邮件协议相关的TCP端口的SSL / TLS通信，例如TCP端口25、465和587，如图19所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-48.jpeg" alt="Figure 19. Using the basic web filter and scrolling through the column display to find spambot traffic."></p>
<p>图19.使用基本的Web过滤器并在列显示中滚动来查找spambot流量。<br>在建立加密的SMTP隧道之前，我们可以对smtp进行过滤以查找一些SMTP命令。图20显示了结果。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-49.jpeg" alt="Figure 20. Filtering for SMTP traffic in our second pcap."></p>
<p>图20.过滤<br>图20.在第二个pcap中过滤SMTP流量。<br>有时，我们可以从受Emotet感染的Windows主机生成的spambot流量中找到未加密的SMTP。未加密的SMTP将显示其邮件内容，但是来自spambot主机的加密SMTP的数量远远大于未加密的SMTP的数量。因此，来自受Emotet感染的主机的大多数spambot邮件都隐藏在加密流量中。</p>
<p>在此示例中，您应该只看到加密的SMTP通信。</p>
<p>但是，我们的下一个示例是后来由于相同的感染而来的，当时我们终于看到了一些未加密的SMTP。</p>
<h2 id="示例3：Emotet和Spambot流量，第2部分"><a href="#示例3：Emotet和Spambot流量，第2部分" class="headerlink" title="示例3：Emotet和Spambot流量，第2部分"></a>示例3：Emotet和Spambot流量，第2部分</h2><p>在Wireshark中打开Example-3-2021-01-05-Emotet-with-spambot-traffic-part-2.pcap，并使用基本的Web过滤器，如图21所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-50.jpeg" alt="Figure 21. Traffic from the third pcap filtered in Wireshark using our basic web filter."></p>
<p>图21.使用基本的Web过滤器在Wireshark中过滤的第三个pcap的流量。<br>在此pcap中，我们仍然看到对Emotet C2流量的HTTP POST请求，每分钟至少两次。我们还可以找到类似于之前的pcap的加密spambot活动。</p>
<p>Spambot活动经常产生大量流量。这个pcap包含来自受感染的Windows主机的4分42秒的spambot活动，并且流量超过21 MB。</p>
<p>通过使用以下Wireshark过滤器，我们可以快速识别任何未加密的SMTP通信：</p>
<p>smtp.data.fragment</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-51.jpeg" alt="Figure 22. Filtering for indicators of unencrypted SMTP from spambot traffic."></p>
<p>图22显示了针对第三个pcap的此过滤器的结果。该筛选器揭示了由受感染的Windows主机生成的五个Emotet垃圾邮件示例。图22.从spambot流量过滤未加密SMTP的指示符。<br>遵循TCP流中来自以下位置的最后一封电子邮件：“ Gladisbel Miranda，UTC时间20:19:54。检查这些消息的外观，如图23所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-52.jpeg" alt="Figure 23. TCP stream for an example of Emotet malspam from our third pcap."></p>
<p>图23. TCP流，这是来自第三个pcap的Emotet恶意垃圾邮件的示例。<br>我们可以使用菜单路径File-&gt; Export Objects-&gt; IMF导出这五个Emotet垃圾邮件，如图24所示。</p>
<p> Thunderbird是一个免费的电子邮件客户端，您可以使用它查看潜在的受害者如何查看这些电子邮件。</p>
<p>如前所述，Emotet还是恶意软件下载器。通过Emotet分发的最常见的恶意软件可能是Trickbot。</p>
<h2 id="实施例4：用Trickbot感染Emotet"><a href="#实施例4：用Trickbot感染Emotet" class="headerlink" title="实施例4：用Trickbot感染Emotet"></a>实施例4：用Trickbot感染Emotet</h2><p>在Wireshark中打开Example-4-2021-01-05-Emotet-infection-with-Trickbot.pcap，并使用基本的Web过滤器，如图25所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-54.jpeg" alt="Figure 25. Traffic from the fourth pcap filtered in Wireshark using our basic web filter."></p>
<p>图25.使用我们的基本Web过滤器在Wireshark中过滤出的第四个pcap的流量。</p>
<p>此pcap没有针对初始Emotet DLL的HTTP GET请求。但是，我们列显示的第一帧显示到fathekarim [.] com的HTTPS流量。这可能是对Emotet DLL的Web请求，因为据报道该域在2021年1月5日（与我们pcap中的流量相同）托管Emotet二进制文件。</p>
<p>您应该找到与Emotet C2关联的两种相同类型的HTTP POST请求，如前两个pcap中所述。</p>
<p>该pcap还包含Trickbot感染的迹象。使用基本的Web过滤器并向下滚动以查找Trickbot流量，如图26所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-55.jpeg" alt="Figure 26. Scrolling down the column display to find Trickbot indicators in our fourth pcap using a basic web filter."></p>
<p>图26.向下滚动列显示，使用基本的Web过滤器在第四个pcap中找到Trickbot指示器。<br>我们在之前的Wireshark教程中检查了Trickbot的感染，其中对Trickbot进行了回顾，但是这里有个快速介绍。以下是Trickbot的常见指标：</p>
<p>在没有关联域或主机名的情况下，通过TCP端口447或449进行的HTTPS通信。<br>通过标准或非标准TCP端口的HTTP POST请求，以/ 81 /，/ 83 /或/ 90结尾的HTTP流量与数据渗透相关联。<br>对于受Emotet感染的Trickbot，上述HTTP POST请求以/ mor开头，后跟一个数字（到目前为止只能看到一个或两个数字）。<br>对以.png结尾的URL的HTTP GET请求，返回其他Trickbot二进制文件。<br>我们可以使用以下Wireshark过滤器轻松找到这些指标：</p>
<ul>
<li>tls.handshake.type eq 1 and (tcp.port eq 447 or tcp.port eq 449)</li>
<li>(http.request.uri contains /81 or http.request.uri contains /83 or http.request.uri contains /90) and http.request.uri contains mor</li>
<li>http.request.uri contains .png</li>
</ul>
<p>图27-29显示了上述每个过滤器的结果。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-56.jpeg" alt="Figure 27.: Filtering for Trickbot HTTPS traffic over TCP port 447 or TCP port 449."></p>
<p>图27 .:通过TCP端口447或TCP端口449过滤Trickbot HTTPS流量。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-57.jpeg" alt="Figure 28. Filtering for HTTP POST requests associated with Trickbot data exfiltration."><br>图28.筛选与Trickbot数据渗透相关的HTTP POST请求。<br>遵循图28所示的每个HTTP POST请求的TCP流，以查看是否泄露了任何密码数据。最后一个以/ 90结尾的HTTP POST请求包含有关受感染Windows主机及其环境的数据。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-58.jpeg" alt="Figure 29. Filtering for HTTP GET requests ending in .png associated with additional Trickbot binaries."></p>
<p>图29.筛选以.png结尾的HTTP GET请求，该请求与其他Trickbot二进制文件关联。</p>
<p>遵循TCP流以处理图29中所示的每个HTTP POST请求，以查看是否返回了Windows二进制文件。这样做应该显示两个Windows可执行文件。然后，您可以使用文件-&gt;导出对象-&gt; HTTP从pcap导出这些二进制文件，如前面的示例中所述。</p>
<p>Trickbot是Emotet发行的最常见的恶意软件，但并非唯一。 Qakbot是另一种经常在受Emotet感染的Windows主机上丢弃的恶意软件。</p>
<h2 id="示例5：用Qakbot感染Emotet"><a href="#示例5：用Qakbot感染Emotet" class="headerlink" title="示例5：用Qakbot感染Emotet"></a>示例5：用Qakbot感染Emotet</h2><p>在Wireshark中打开Example-5-2020-08-18-Emotet-infection-with-Qakbot.pcap，并使用基本的Web过滤器，如图30所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-59.jpeg" alt="Figure 30. Traffic from the fifth pcap filtered in Wireshark using our basic web filter."></p>
<p>图30.使用我们的基本Web过滤器在Wireshark中过滤了来自第五个pcap的流量。<br>在第五封pcap中，在世界标准时间21:23:50从savetpranamam.mysquare [.] in中检索了一个Emotet Word文档，该文档与报告在同一日期托管Emotet Word文档的URL相匹配。如先前示例中所述，使用文件-&gt;导出对象-&gt; HTTP从pcap导出此Word文档。</p>
<p>此提取的Word文档的SHA256哈希为：</p>
<p>c7f429dde8986a1b2fc51a9b3f4a78a92311677a01790682120ab603fd3c2fcb<br>我们还在世界标准时间21:24:40看到到samaritantec [.] com的HTTPS流量。据报道，该域在同一日期托管了Emotet二进制文件。</p>
<p>与前面的示例一样，您应该找到与Emotet C2流量关联的两种相同类型的HTTP POST请求。</p>
<p>此外，该pcap包含Qakbot感染的指示。使用基本的Web过滤器并向下滚动以查找Qakbot流量，如图31所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-60.jpeg" alt="Figure 31. Scrolling down the column display to find Qakbot indicators in our fifth pcap using a basic web filter."></p>
<p>图31.向下滚动列显示，使用基本的Web过滤器在第五个pcap中找到Qakbot指示器。<br>我们在之前的Wireshark教程中检查了Qakbot，该教程介绍了如何检查Qakbot感染，但是这里不容赘述。以下是Qakbot的常见指标：</p>
<p>通过HTTPS的标准和非标准TCP端口进行的HTTPS流量。<br>Qakbot HTTPS流量的证书数据在颁发者字段中具有异常值，并且证书不是由美国的颁发机构颁发的。<br>通过TCP端口65400的TCP流量。<br>2020年11月下旬之前，Qakbot通常生成到cdn.speedof [.] me的HTTPS流量。<br>2020年11月下旬之前，Qakbot通常会向a.strandsglobal [.] com生成HTTP GET请求。<br>我们可以使用以下Wireshark过滤器轻松找到这些指标：</p>
<ul>
<li>tls.handshake.type eq 11 and !(x509sat.CountryName == US)</li>
<li>tcp.port eq 65400</li>
<li>tls.handshake.extensions_server_name contains speedof</li>
<li>http.host contains strandsglobal</li>
</ul>
<p>图32-35显示了上述每个过滤器的结果。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-61.jpeg" alt="Figure 32. Filtering and searching for unusual certificate issuer data in HTTPS traffic generated by Qakbot."><br>图32.过滤和搜索Qakbot生成的HTTPS通信中的异常证书颁发者数据。<br>在图32中，第一个过滤器的结果在来自71.80.66 [.] 107的流量的列显示中显示了几帧。搜索框架详细信息，并找到异常的证书颁发者数据，如上所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-62.jpeg" alt="Figure 33. Filtering for Qakbot traffic over TCP port 65400.">图33.过滤TCP端口65400上的Qakbot流量。<br>图33.过滤TCP端口65400上的Qakbot流量。<br>在上图中，我们在TCP端口65400上找到了一个Qakbot通信的TCP流。该流包含受感染Qakbot的Windows主机的公共IP地址和一个僵尸网络标识字符串。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-63.jpeg" alt="Figure 34. Filtering for traffic to cdn.speedof[.]me, which is not inherently malicious, but a connectivity check caused by Qakbot prior to late November 2020."><br>图34.过滤到cdn.speedof.me的流量，这不是天生的恶意，而是Qakbot在2020年11月下旬之前引起的连接检查。<br><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2021/01/word-image-64.jpeg" alt="Figure 35. Filtering for traffic to a.stransglobal[.]com, typically generated by Qakbot prior to late November 2020."><br>图35.过滤到a.stransglobal [.] com的流量，通常由Qakbot在2020年11月下旬之前生成。<br>当Emotet通常会删除Trickbot和Qakbot，请注意，Emotet还删除了其他类型的恶意软件，例如Gootkit和IcedID。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本教程回顾了如何从感染流量的pcap中识别Emotet活动。我们回顾了五个最近的pcaps，发现由Emotet C2流量引起的HTTP POST请求中的相似之处。这些模式非常独特，可用于识别网络中的Emotet感染。我们还回顾了与Emotet相关的其他感染后活动，例如垃圾邮件程序流量和被感染主机上丢弃的各种恶意软件家族。</p>
<p>这些知识可以帮助安全专业人员在检查可疑网络活动时更好地检测和捕获Emotet感染。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E8%A7%A3%E5%AF%86https%E6%B5%81%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E8%A7%A3%E5%AF%86https%E6%B5%81%E9%87%8F/" itemprop="url">Wireshark教程：解密https流量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-03T18:38:15+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="解密https流量"><a href="#解密https流量" class="headerlink" title="解密https流量"></a>解密https流量</h1><p>本教程适用于调查可疑网络活动并查看流量的数据包捕获（pcaps）的安全专业人员。这些说明假定您熟悉Wireshark，并且重点介绍Wireshark版本3.x。</p>
<p>在审查可疑的网络活动时，我们经常会遇到加密的流量。为什么？因为大多数网站使用安全超文本传输协议（HTTPS）协议。但是像大多数网站一样，各种类型的恶意软件也使用HTTPS。查看恶意软件活动产生的数据后，了解感染后流量中包含的内容非常有帮助。</p>
<p>该Wireshark教程描述了如何从Wireshark中的pcap解密HTTPS流量。可以使用基于文本的日志进行解密，该日志包含最初记录pcap时捕获的加密密钥数据。使用此密钥日志文件，我们可以在pcap中解密HTTPS活动并查看其内容。</p>
<p>今天，我们将检查来自Dridex恶意软件感染的HTTPS活动。</p>
<p>注意：我们的说明假定您已按照“自定义Wireshark –更改列显示”中的说明自定义了Wireshark列显示。</p>
<p>这是一个Github存储库，其中包含ZIP存档，其中包含本教程使用的pcap和密钥日志文件。</p>
<p>警告：本教程使用的pcap包含基于Windows的恶意软件。如果使用Windows计算机，则存在感染的风险。我们建议您尽可能在非Windows环境（例如BSD，Linux或macOS）中查看此pcap。</p>
<h2 id="0x01-加密流量背后的上下文"><a href="#0x01-加密流量背后的上下文" class="headerlink" title="0x01 加密流量背后的上下文"></a>0x01 加密流量背后的上下文</h2><p>在1990年代中期至后期，网站使用的最常见协议是超文本传输协议（HTTP），该协议生成未加密的Web流量。但是，随着安全性日益受到关注，网站开始切换到HTTPS，现在我们很少看到来自Web浏览的HTTP流量。</p>
<p>HTTPS本质上是一个包含HTTP流量的加密通信隧道。这些隧道首先使用安全套接字层（SSL）作为加密协议。如今，大多数HTTPS流量都使用传输层安全性（TLS）。</p>
<h2 id="0x02-HTTPS-Web流量"><a href="#0x02-HTTPS-Web流量" class="headerlink" title="0x02 HTTPS Web流量"></a>0x02 HTTPS Web流量</h2><p>HTTPS流量通常会显示一个域名。例如，当在Web浏览器中查看<a href="https://www.wireshark.org时，在自定义的Wireshark列显示中查看时，pcap将显示www.wireshark.org作为此流量的服务器名称。不幸的是，我们不知道其他详细信息，例如实际的URL或从服务器返回的数据。从pcap遵循传输控制协议（TCP）流将不会显示此流量的内容，因为它是经过加密的。" target="_blank" rel="noopener">https://www.wireshark.org时，在自定义的Wireshark列显示中查看时，pcap将显示www.wireshark.org作为此流量的服务器名称。不幸的是，我们不知道其他详细信息，例如实际的URL或从服务器返回的数据。从pcap遵循传输控制协议（TCP）流将不会显示此流量的内容，因为它是经过加密的。</a></p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/08/word-image.jpeg" alt="The screenshots show what is seen when viewing https://www.wireshark.org in a web browser, vs. what a pcap would show when viewed in a customized Wireshark column display. "></p>
<p>屏幕截图显示了在Web浏览器中查看<a href="https://www.wireshark.org时看到的内容，以及在自定义的Wireshark列显示中查看pcap时显示的内容。" target="_blank" rel="noopener">https://www.wireshark.org时看到的内容，以及在自定义的Wireshark列显示中查看pcap时显示的内容。</a><br>图1.从HTTPS流量到<a href="http://www.wireshark.org的流量。" target="_blank" rel="noopener">www.wireshark.org的流量。</a><br>Wireshark-遵循TCP流（tcp.stream eq0）-以太网0</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/08/word-image-1.jpeg" alt="Wireshark - Follow TCP Stream (tcp.stream eq0) - Ethernet0"></p>
<p>图2.往返于<a href="http://www.wireshark.org的服务器的HTTPS流量的TCP流。" target="_blank" rel="noopener">www.wireshark.org的服务器的HTTPS流量的TCP流。</a></p>
<h2 id="0x03-加密密钥日志文件"><a href="#0x03-加密密钥日志文件" class="headerlink" title="0x03 加密密钥日志文件"></a>0x03 加密密钥日志文件</h2><p>加密密钥日志是一个文本文件。一个示例如图3所示。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/08/word-image-2.jpeg" alt="Wireshark-tutorial-KeysLogFile.txt - Mousepad"><br>图3.本教程中使用的关键日志文件。<br>最初记录pcap时，使用中间人（MitM）技术创建这些日志。如果在记录pcap时未创建此类文件，则无法解密该pcap中的HTTPS流量。</p>
<h2 id="0x04-具有密钥日志文件的Pcap的示例"><a href="#0x04-具有密钥日志文件的Pcap的示例" class="headerlink" title="0x04 具有密钥日志文件的Pcap的示例"></a>0x04 具有密钥日志文件的Pcap的示例</h2><p>这个Github存储库<a href="https://github.com/pan-unit42/wireshark-tutorial-decrypting-HTTPS-traffic中提供了一个受密码保护的ZIP归档文件，其中包含pcap及其密钥日志文件。转到Github页面，单击ZIP存档条目，然后如图4和5所示下载它。值得注意的是，此ZIP存档中包含的pcap通过密钥日志解密后，可以访问基于Windows的恶意软件样本。与往常一样，我们建议您在非Windows环境中谨慎行事并按照本教程中的步骤进行操作。" target="_blank" rel="noopener">https://github.com/pan-unit42/wireshark-tutorial-decrypting-HTTPS-traffic中提供了一个受密码保护的ZIP归档文件，其中包含pcap及其密钥日志文件。转到Github页面，单击ZIP存档条目，然后如图4和5所示下载它。值得注意的是，此ZIP存档中包含的pcap通过密钥日志解密后，可以访问基于Windows的恶意软件样本。与往常一样，我们建议您在非Windows环境中谨慎行事并按照本教程中的步骤进行操作。</a></p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2020/08/word-image-3.jpeg" alt="pan-unit42/wireshark-tutorial-decrypting-HTTPS-traffic - the screenshot shows the Github repository with the link to the ZIP archive used for this tutorial on decrypting HTTPS traffic. "></p>
<p>pan-unit42 / wireshark-tutorial-decrypting-HTTPS-traffic-屏幕快照显示了Github存储库，其中包含指向本教程有关解密HTTPS流量的ZIP存档的链接。<br>图4. Github存储库，带有指向本教程使用的ZIP存档的链接。<br>pan-unit42 / wireshark-tutorial-decrypting-HTTPS-traffic-屏幕快照显示了如何在Github存储库中下载用于本教程的解密HTTPS流量的ZIP存档。<br>图5.下载本教程的ZIP存档。<br>使用感染的作为密码来提取pcap和密钥日志文件</p>
<ul>
<li>Wireshark-tutorial-KeysLogFile.txt</li>
<li>Wireshark-tutorial-on-decrypting-HTTPS-SSL-TLS-traffic.pcap</li>
</ul>
<p>从ZIP存档中。这将提供两个文件。</p>
<h2 id="0x05-没有密钥日志文件的HTTPS流量"><a href="#0x05-没有密钥日志文件的HTTPS流量" class="headerlink" title="0x05 没有密钥日志文件的HTTPS流量"></a>0x05 没有密钥日志文件的HTTPS流量</h2><p>在Wireshark中打开pcap。使用基本的basic：</p>
<p>![image-20210403182308872](/Users/yueting/Library/Application Support/typora-user-images/image-20210403182308872.png)</p>
<p>此pcap来自Windows 10主机上的Dridex恶意软件感染。所有Web流量（包括感染活动）都是HTTPS。没有密钥日志文件，我们将看不到流量的任何详细信息，只有IP地址，TCP端口和域名。</p>
<h2 id="0x06-加载密钥日志文件"><a href="#0x06-加载密钥日志文件" class="headerlink" title="0x06 加载密钥日志文件"></a>0x06 加载密钥日志文件</h2><p>在Wireshark中打开pcap。然后使用菜单路径Edit-&gt; Preferences来打开Preferences菜单，在Preferences菜单的左侧，单击Protocols。（macos的在wireshark下的perferences）</p>
<p>![](/Users/yueting/Library/Application Support/typora-user-images/image-20210403182802760.png)</p>
<p>在Wireshark-“首选项”菜单的左侧，单击“协议”，如此处所示。<br>图9.在“首选项”菜单中选择“协议”。<br>如果您使用的是Wireshark版本2.x，请向下滚动直到找到SSL并选择它。如果使用的是Wireshark 3.x版，请向下滚动到TLS并选择它。</p>
<p>![image-20210403182843840](/Users/yueting/Library/Application Support/typora-user-images/image-20210403182843840.png)选择SSL或TLS后，应该看到（Pre）-Master-Secret log filename。单击“浏览”按钮，然后选择名为Wireshark-tutorial-KeysLogFile.txt的密钥日志文件。</p>
<p>![image-20210403182935612](/Users/yueting/Library/Application Support/typora-user-images/image-20210403182935612.png)<br>图11.选择本教程的关键日志文件。<br>图12.将文件选择为（Pre）-Master-Secret日志文件名后，单击“ OK”。</p>
<h2 id="0x07带有密钥日志文件的HTTPS流量"><a href="#0x07带有密钥日志文件的HTTPS流量" class="headerlink" title="0x07带有密钥日志文件的HTTPS流量"></a>0x07带有密钥日志文件的HTTPS流量</h2><p>一旦单击“ OK”，在使用基本过滤器时，Wireshark列显示将在每条HTTPS行下列出解密的HTTP请求，如图13所示。</p>
<p>![image-20210403183026598](/Users/yueting/Library/Application Support/typora-user-images/image-20210403183026598.png)<br>图13.使用密钥日志文件后，Wireshark中的HTTPS解密。<br>在此pcap中，我们现在看到以前隐藏在HTTPS通信中的对microsoft.com和skype.com域的HTTP请求。我们还发现由Dridex感染引起的以下流量：</p>
<ul>
<li>foodsgoodforliver[.]com - GET /invest_20.dll</li>
<li>105711[.]com - POST /docs.php</li>
</ul>
<p>对foodsgoodforliver [.] com的GET请求返回了Dridex的DLL文件。对105711 [.] com的POST请求是来自受Dridex感染的Windows主机的命令和控制（C2）通信。</p>
<p>我们可以通过跟踪HTTP流来查看流量。右键单击该行以将其选中，然后单击鼠标左键以弹出一个菜单以遵循HTTP流。图14和15显示了针对foodsgoodforliver [.] com的HTTP GET请求的HTTP流。</p>
<p>![image-20210403183254419](/Users/yueting/Library/Application Support/typora-user-images/image-20210403183254419.png)</p>
<p>![image-20210403183404236](/Users/yueting/Library/Application Support/typora-user-images/image-20210403183404236.png)<br>图15. HTTP流指示从服务器返回的EXE或DLL。<br>由于我们具有用于此流量的密钥日志文件，因此我们现在可以从pcap导出此恶意软件。使用菜单路径File-&gt; Export Objects-&gt; HTTP从pcap导出此文件，如图16所示。</p>
<p>![image-20210403183528123](/Users/yueting/Library/Application Support/typora-user-images/image-20210403183528123.png)<br>可以在公开可用的在线沙箱环境中找到结果。</p>
<p>最后，我们可以检查来自此Dridex感染的C2流量。使用您的basic过滤，然后遵循从其中一个POST请求到105711 .com的HTTP流。图18显示了来自HTTP流之一的示例。</p>
<p>![image-20210403183800965](/Users/yueting/Library/Application Support/typora-user-images/image-20210403183800965.png)</p>
<p>来自Dridex C2 POST请求之一的HTTP流。<br>图18.来自Dridex C2 POST请求之一的HTTP流。<br>结论<br>本教程回顾了如何使用密钥日志文本文件通过Wireshark在pcap中解密HTTPS流量。如果没有在最初记录pcap时创建密钥日志文件，则无法在Wireshark中解密来自该pcap的HTTPS通信。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%BB%A4/" itemprop="url">Wireshark教程：设置过滤</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-03T18:11:45+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="wireshark设置过滤"><a href="#wireshark设置过滤" class="headerlink" title="wireshark设置过滤"></a>wireshark设置过滤</h1><h2 id="1-感染流量指标"><a href="#1-感染流量指标" class="headerlink" title="1.感染流量指标"></a>1.感染流量指标</h2><p>本教程使用Windows感染流量示例，这些流量来自通过大规模分发方法（如恶意垃圾邮件（malspam））或Web流量分发的商品恶意软件。 在恶意软件（通常是Windows可执行文件）感染Windows主机之前，这些感染可以遵循许多不同的路径。</p>
<p>指标包括从网络流量中获取的与感染相关的信息。 这些指标通常称为危害指标（IOC）。 安全专业人员经常记录与Windows感染流量相关的指示器，例如URL，域名，IP地址，协议和端口。 正确使用Wireshark显示过滤器可以帮助人们快速找到这些指标。</p>
<h2 id="2-Wireshark显示过滤器"><a href="#2-Wireshark显示过滤器" class="headerlink" title="2.Wireshark显示过滤器"></a>2.Wireshark显示过滤器</h2><p>经常使用到的</p>
<p> Equals: == or eq<br> And: &amp;&amp; or and<br> Or: || (double pipe) or or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip.addr eq 192.168.10.195 and ip.addr &#x3D;&#x3D; 192.168.10.1</span><br><span class="line">http.request &amp;&amp; ip.addr &#x3D;&#x3D; 192.168.10.195</span><br><span class="line">http.request || http.response</span><br><span class="line">dns.qry.name contains microsoft or dns.qry.name contains windows</span><br></pre></td></tr></table></figure>

<p>指定排除值时，请勿在过滤器表达式中使用!=。例如，如果要指定不包含IP地址192.168.10.1的所有流量，请使用!(ip.addr eq 192.168.10.1)而不是ip.addr!= 192.168.10.1。</p>
<h2 id="3-过滤基于Web的感染流量"><a href="#3-过滤基于Web的感染流量" class="headerlink" title="3.过滤基于Web的感染流量"></a>3.过滤基于Web的感染流量</h2><p>快速查看pcap中的网络流量:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request <span class="keyword">or</span> ssl.handshake.type == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>值http.request显示HTTP请求的URL，而ssl.handshake.type == 1显示HTTPS或SSL / TLS通信中使用的域名。</p>
<p>但是，我也使用Windows 7主机生成pcaps流量，并且该流量包括在正常活动期间通过UDP端口1900发出的HTTP请求。 UDP端口1900上的HTTP通信是简单服务发现协议（SSDP）。 SSDP是用于发现即插即用设备的协议，它与正常的网络流量无关。 因此，我使用以下表达式将其过滤掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.request or ssl.handshake.type &#x3D;&#x3D; 1 and !(udp.port eq 1900)</span><br><span class="line"></span><br><span class="line">http.request or ssl.handshake.type &#x3D;&#x3D; 1 and !(ssdp)</span><br></pre></td></tr></table></figure>

<p>从Windows 7主机上的感染中检查pcap时，过滤出SSDP活动可提供非常清晰的流量视图。 图6显示了从2018年12月3日开始在Windows 7主机上具有IcedID感染流量的Emotet活动。 它针对包含SSDP请求的Web流量进行过滤。 图7显示了对除SSDP请求之外的Web流量进行过滤的相同pcap，它提供了更清晰的活动图。</p>
<p>![image-20210403161803286](/Users/yueting/Library/Application Support/typora-user-images/image-20210403161803286.png)</p>
<p>添加!ssdp后更加清晰</p>
<p>![image-20210403161902711](/Users/yueting/Library/Application Support/typora-user-images/image-20210403161902711.png)</p>
<p>在图7中，我们看到了一些感染流量的指标，但并非所有感染指标都可以显示出来。 在某些情况下，受感染的主机可能会尝试与已脱机或拒绝TCP连接的服务器连接。 通过添加tcp.flags eq 0x0002在过滤器中包含TCP SYN段，可以揭示这些尝试的连接。 对相同的流量尝试以下过滤器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(http.request or ssl.handshake.type &#x3D;&#x3D; 1 or tcp.flags eq 0x0002) and !(udp.port eq 1900)</span><br></pre></td></tr></table></figure>

<p>![image-20210403162012446](/Users/yueting/Library/Application Support/typora-user-images/image-20210403162012446.png)</p>
<p>其中黑色部分三次握手没有回应</p>
<p>在搜索中包括TCP SYN段，这表明受感染的主机还试图通过TCP端口8443与IP地址217.164.2 .133连接。</p>
<h2 id="4-过滤其他类型的感染流量"><a href="#4-过滤其他类型的感染流量" class="headerlink" title="4.过滤其他类型的感染流量"></a>4.过滤其他类型的感染流量</h2><p>在某些情况下，感染后流量将不是基于Web的，并且被感染的主机将与命令和控制（C2）服务器联系。 这些服务器可以直接托管在IP地址上，也可以托管在使用域名的服务器上。 某些感染后活动（例如，由Nanocore远程访问工具（RAT）引起的C2通信）不是HTTP或HTTPS / SSL / TLS通信。</p>
<p>因此，在查看pcap来查看流量中是否有任何这些域处于活动状态时，我经常添加DNS活动。 这将导致以下过滤器表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(http.request or ssl.handshake.type &#x3D;&#x3D; 1 or tcp.flags eq 0x0002 or dns) and !(udp.port eq 1900)</span><br></pre></td></tr></table></figure>

<p>我使用上面的过滤器表达式查看了pcap，该pcap显示了从<a href="http://www.mercedes-club-bg" target="_blank" rel="noopener">www.mercedes-club-bg</a> [.]com下载的Nanocore RAT可执行文件，以感染易受攻击的Windows主机。 初始下载后，尝试通过TCP连接到185.163.45 [.]48上的franex.sytes [.]net和95.213.251 [.]165上的franexserve.duckdns [.]org。 图10显示了DNS查询和TCP流量之间的相关性。</p>
<p>![image-20210403162522125](/Users/yueting/Library/Application Support/typora-user-images/image-20210403162522125.png)</p>
<p>某些感染流量使用的通用协议很容易被Wireshark解码。 图11显示了由该恶意软件可执行文件产生的感染后流量，该可执行文件生成FTP流量。 使用标准的网络流量搜索（该功能还会检查DNS流量和TCP SYN标志），在对ftp.totallyanonymous [.] com进行DNS查询之后，我们可以找到TCP端口21和其他TCP端口上的流量。</p>
<p>![image-20210403162848799](/Users/yueting/Library/Application Support/typora-user-images/image-20210403162848799.png)</p>
<p>![image-20210403163114324](/Users/yueting/Library/Application Support/typora-user-images/image-20210403163114324.png)</p>
<p>检索两个文件</p>
<p>向下滚动至以后的FTP通信，如图13所示，您将发现大约每分钟发送到FTP服务器的名为6R7MELYD6的文件。 进一步调查将发现6R7MELYD6包含从受感染Windows主机窃取的密码数据。</p>
<p>![image-20210403163253046](/Users/yueting/Library/Application Support/typora-user-images/image-20210403163253046.png)</p>
<p>除了FTP，恶意软件还可以使用其他通用协议来处理恶意流量。 Spambot恶意软件可以将受感染的主机转变为旨在每分钟发送数十至数百封电子邮件的spambot。 它的特征是对各种邮件服务器的几个DNS请求，然后是TCP端口25、465、587或与电子邮件流量关联的其他TCP端口上的SMTP流量。</p>
<p>（http.request或ssl.handshake.type == 1或tcp.flags eq 0x0002或dns）和！（udp.port eq 1900）</p>
<p>在查看spambot流量时，您会发现对邮件服务器的DNS查询和对与SMTP相关的端口的TCP通信。</p>
<p>如果将smtp用作过滤器表达式，则会发现几个结果。如果您发现STARTTLS，则可能是经过加密的SMTP通信，并且您将无法看到电子邮件数据。</p>
<p>smtp contains “From: “<br>smtp contains “Message-ID: “<br>smtp contains “Subject: “</p>
<p>![image-20210403163816906](/Users/yueting/Library/Application Support/typora-user-images/image-20210403163816906.png)</p>
<p>![image-20210403163849039](/Users/yueting/Library/Application Support/typora-user-images/image-20210403163849039.png)</p>
<p>tcp流</p>
<h2 id="5-保存过滤器"><a href="#5-保存过滤器" class="headerlink" title="5.保存过滤器"></a>5.保存过滤器</h2><p>basic (http.request or ssl.handshake.type == 1) and !(udp.port eq 1900)<br>basic+ (http.request or ssl.handshake.type == 1 or tcp.flags eq 0x0002) and !(udp.port eq 1900)<br>basic+DNS (http.request or ssl.handshake.type == 1 or tcp.flags eq 0x0002 or dns) and !(udp.port eq 1900)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Wireshark%E5%AF%BB%E6%89%BE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2021/04/03/Wireshark%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8Wireshark%E5%AF%BB%E6%89%BE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF/" itemprop="url">Wireshark教程：使用Wireshark寻找主机信息</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-03T18:00:53+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用Wireshark寻找主机信息"><a href="#使用Wireshark寻找主机信息" class="headerlink" title="使用Wireshark寻找主机信息"></a>使用Wireshark寻找主机信息</h1><p>网络中产生流量的任何主机都应具有三个标识符：MAC地址，IP地址和主机名。</p>
<p>我们如何使用Wireshark查找此类主机信息？我们对两种活动进行过滤：DHCP或NBNS。 DHCP流量可以帮助识别连接到网络的几乎所有类型的计算机的主机。 NBNS流量主要由运行Microsoft Windows的计算机或运行MacOS的Apple主机生成。</p>
<h2 id="实验一来自DHCP流量的主机信息"><a href="#实验一来自DHCP流量的主机信息" class="headerlink" title="实验一来自DHCP流量的主机信息"></a>实验一来自DHCP流量的主机信息</h2><p>![image-20210403144915421](/Users/yueting/Library/Application Support/typora-user-images/image-20210403144915421.png)</p>
<p>DHCP traffic can help identify hosts for almost any type of computer connected to your network.</p>
<p> DHCP Request &gt;Bootstrap Protocol (Request)&gt; Client Identifier and Host Name</p>
<p>![image-20210403145148267](/Users/yueting/Library/Application Support/typora-user-images/image-20210403145148267.png)</p>
<p>通过这里 似乎是一个ipad，但是不能仅凭一个主机名确定</p>
<p>在这种情况下，172.16.1 [.] 207的主机名是Rogers-iPad，MAC地址是7c：6d：62：d2：e3：4f。此MAC地址已分配给Apple。根据主机名，此设备可能是iPad，但我们无法仅通过主机名进行确认。</p>
<p>MAC address and IP address（找相关的）</p>
<p>![image-20210403145658069](/Users/yueting/Library/Application Support/typora-user-images/image-20210403145658069.png)</p>
<h2 id="实验二-来自NetBIOS名称服务（NBNS）流量的主机信息"><a href="#实验二-来自NetBIOS名称服务（NBNS）流量的主机信息" class="headerlink" title="实验二 来自NetBIOS名称服务（NBNS）流量的主机信息"></a>实验二 来自NetBIOS名称服务（NBNS）流量的主机信息</h2><p> NBNS traffic is generated primarily by computers running Microsoft Windows or Apple hosts running MacOS.</p>
<p>根据更新DHCP租约的频率，您的pcap中可能没有DHCP流量。幸运的是，我们可以使用NBNS流量来标识运行Microsoft Windows的计算机或运行MacOS的Apple主机的主机名。</p>
<p>NBNS(NetBIOS Name Server)是动态DNS的一种，Microsoft的NBNS实现称为WINS</p>
<p>![image-20210403150214758](/Users/yueting/Library/Application Support/typora-user-images/image-20210403150214758.png)</p>
<p>该主机使用内部IP地址10.2.4.101。在Wireshark中打开pcap，然后在nbns上进行过滤。这应该显示NBNS流量。选择第一帧，您可以快速将IP地址与MAC地址和主机名相关联，如图所示。</p>
<p>从这里也可以看到一些细节</p>
<p>![image-20210403150323755](/Users/yueting/Library/Application Support/typora-user-images/image-20210403150323755.png)</p>
<h2 id="实验三-来自HTTP流量的设备模型和操作系统"><a href="#实验三-来自HTTP流量的设备模型和操作系统" class="headerlink" title="实验三 来自HTTP流量的设备模型和操作系统"></a>实验三 来自HTTP流量的设备模型和操作系统</h2><p>来自HTTP通信头的用户代理字符串可以显示操作系统。如果HTTP流量来自Android设备，那么还可以确定设备的制造商和型号。</p>
<p>过滤： http.request and !(ssdp)</p>
<p>此pcap来自Windows主机，使用内部IP地址192.168.1 .97。在Wireshark中打开pcap，然后对http.request and !(ssdp)进行过滤。选择第二个帧，这是对<a href="http://www.ucla" target="_blank" rel="noopener">www.ucla</a> . edu的第一个HTTP请求，并跟踪TCP流，如图所示。</p>
<p>![image-20210403150601328](/Users/yueting/Library/Application Support/typora-user-images/image-20210403150601328.png)</p>
<p>![image-20210403150645206](/Users/yueting/Library/Application Support/typora-user-images/image-20210403150645206.png)</p>
<p>该TCP流具有HTTP请求标头，如图所示。User-Agent行表示在Microsoft Windows 7 x64操作系统上运行的Google Chrome浏览器Web版本72.0.3626. 81。</p>
<p>Note the following string in the User-Agent line from Figure 8:</p>
<p>(Windows NT 6.1; Win64; x64)</p>
<ul>
<li><pre><code>NT字符串表示以下版本的Microsoft Windows
- Windows NT 5.1: Windows XP
- Windows NT 6.0: Windows Vista
- Windows NT 6.1: Windows 7
- Windows NT 6.2: Windows 8
- Windows NT 6.3: Windows 8.1
- Windows NT 10.0: Windows 10
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 实验四 DHCP流量中的主机信息</span><br><span class="line"></span><br><span class="line">使用来自Windows主机的基于HTTP的web浏览流量，可以确定操作系统和浏览器。来自Android设备的相同类型的流量可以揭示设备的品牌和型号。</span><br><span class="line"></span><br><span class="line">此pcap来自使用内部IP地址172.16.4.119的Android主机。在Wireshark中打开pcap，然后对http.request进行过滤。选择第二个框架，这是对&#x2F;blank.html的www.google.com的HTTP请求。跟踪TCP流。</span><br><span class="line"></span><br><span class="line">![image-20210403151129755](&#x2F;Users&#x2F;yueting&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210403151129755.png)</span><br><span class="line"></span><br><span class="line">User-Agent行显示了Android 7.1.2，它是2017年4月发布的Android操作系统的较旧版本。LM-X210APM表示此Android设备的型号。 Google进行了快速搜索，发现该型号是LG Phoenix 4 Android智能手机。</span><br><span class="line"></span><br><span class="line">来自iPhone或其他苹果移动设备的HTTP流量的用户代理行将为您提供操作系统，并提供设备类型。我们只能确定苹果的设备是iPhone、iPad还是iPod</span><br><span class="line"></span><br><span class="line">## 实验五 </span><br><span class="line"></span><br><span class="line">此pcap来自使用内部IP地址为10.0.0.114的iPhone主机。在Wireshark中打开pcap，然后对http.request进行过滤。选择对web.mta.info的第一个HTTP请求的帧，并遵循TCP流</span><br><span class="line"></span><br><span class="line">![image-20210403151440508](&#x2F;Users&#x2F;yueting&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210403151440508.png)</span><br><span class="line"></span><br><span class="line">(iPhone; CPU iPhone OS 12_1_3 like Mac OS X</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于HTTP流量和用户代理字符串的最后一点说明：并非所有HTTP活动都是web浏览流量。某些HTTP请求不会显示浏览器或操作系统。当您在流量中搜索以识别主机时，在查找web浏览器流量之前，可能需要尝试几个不同的HTTP请求。</span><br><span class="line">由于越来越多的网站使用HTTPS，这种主机识别方法可能很困难。HTTP头和内容在HTTPS通信中不可见。然而，对于那些有幸在调查期间发现HTTP web浏览流量的人来说，这种方法可以提供更多关于主机的信息。</span><br><span class="line"></span><br><span class="line">## 实验六Windows用户帐户来自Kerberos流量</span><br><span class="line"></span><br><span class="line">对于Active Directory（AD）环境中的Windows主机，我们可以从Kerberos通信中找到用户帐户名。</span><br></pre></td></tr></table></figure>
Domain: happycraft[.]org
Network segment: 172.16.8.0/24 (172.16.8[.]0 - 172.16.8[.]255)
Domain controller IP: 172.16.8[.]8
Domain controller hostname: Happycraft-DC
Segment gateway: 172.16.8[.]1
Broadcast address: 172.16.8[.]255
Windows client: 172.16.8[.]201</code></pre><p>kerberos.CNameString</p>
</li>
</ul>
<p>在Wireshark中打开pcap，并在kerberos.CNameString上进行过滤。选择第一帧。转到frame details部分，然后展开行，如图13所示。选择带有CNameString的行：johnson-pc $并将其作为一列应用。</p>
<p>![image-20210403151646754](/Users/yueting/Library/Application Support/typora-user-images/image-20210403151646754.png)</p>
<p>这将创建一个名为CNameString的新列。向下滚动到列显示中的最后一帧。您应该在域控制器172.16.8 [。] 8和Windows客户端172.16.8 [。] 201之间的通信中找到Theresa.johnson的用户帐户名，如图14所示。</p>
<p>![image-20210403151802871](/Users/yueting/Library/Application Support/typora-user-images/image-20210403151802871.png)</p>
<p>主机名的CNameString值总是以$（美元符号）结尾，而用户帐户名则不是。要根据用户帐户名进行筛选，请使用以下Wireshark表达式消除带有美元符号的CNameString结果：</p>
<p>kerberos.CNameString and !(kerberos.CNameString contains $)</p>
<p>![image-20210403151917676](/Users/yueting/Library/Application Support/typora-user-images/image-20210403151917676.png)</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2021/04/03/wireshark%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2021/04/03/wireshark%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8/" itemprop="url">wireshark初步入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-03T14:46:35+08:00">
                2021-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="wireshark导出文件"><a href="#wireshark导出文件" class="headerlink" title="wireshark导出文件"></a>wireshark导出文件</h1><h2 id="1-从HTTP通信中导出对象"><a href="#1-从HTTP通信中导出对象" class="headerlink" title="1.从HTTP通信中导出对象"></a>1.从HTTP通信中导出对象</h2><p>![image-20210403165009709](/Users/yueting/Library/Application Support/typora-user-images/image-20210403165009709.png)</p>
<p>第一个请求以.doc结尾，表示第一个请求返回了Microsoft Word文档。第二个请求以.exe结尾，表示第二个请求返回了Windows可执行文件。 HTTP GET请求在下面列出</p>
<p>smartfax[.]com  GET /Documents/Invoice&amp;MSORequest.doc<br>smartfax[.]com  GET /knr.exe</p>
<p>我们可以使用菜单路径从HTTP对象列表中导出这些对象：File-&gt; Export Objects-&gt; HTTP …图2在Wireshark中显示了此菜单路径。</p>
<p>![image-20210403165214017](/Users/yueting/Library/Application Support/typora-user-images/image-20210403165214017.png)</p>
<p>值得注意的是，HTTP对象列表中的“内容类型”显示了服务器如何在其HTTP响应标头中识别文件。在某些情况下，有意将Windows可执行文件标记为其他类型的文件，以避免被检测到。</p>
<p>在MacBook或Linux环境中，可以将终端窗口或命令行界面（CLI）用于以下命令：</p>
<p>file [filename]<br>shasum -a 256 [filename]</p>
<p>![image-20210403165557862](/Users/yueting/Library/Application Support/typora-user-images/image-20210403165557862.png)</p>
<p>上面的信息确认我们怀疑的Word文档实际上是Microsoft Word文档。它还确认可疑的Windows可执行文件确实是Windows可执行文件。我们可以针对VirusTotal检查SHA256哈希值，以查看是否将这些文件检测为恶意软件。我们还可以对SHA256哈希进行Google搜索，以查找其他信息。</p>
<p>![image-20210403165653362](/Users/yueting/Library/Application Support/typora-user-images/image-20210403165653362.png)</p>
<p>除了Windows可执行文件或其他恶意软件文件外，我们还可以提取网页。本教程的第二个pcap提取对象来自pcap-example-02.pcap（在此处可用）包含有人在伪造的PayPal登录页面上输入登录凭据的流量。</p>
<p>查看来自网络钓鱼站点的网络流量时，我们可能希望查看网络钓鱼网页的外观。我们可以使用Export HTTP object菜单提取初始HTML页面，如图6所示。然后，我们可以在隔离的环境中通过Web浏览器查看它，如图7所示。</p>
<p>![image-20210403165943093](/Users/yueting/Library/Application Support/typora-user-images/image-20210403165943093.png)</p>
<p>图6.从第二个pcap导出伪造的PayPal登录页面。</p>
<p><img src="https://unit42.paloaltonetworks.com/wp-content/uploads/2019/07/word-image-6.png" alt="img"></p>
<p>图7.在Web浏览器中查看的导出的伪造PayPal登录页面。</p>
<h2 id="2-从SMB流量导出对象"><a href="#2-从SMB流量导出对象" class="headerlink" title="2.从SMB流量导出对象"></a>2.从SMB流量导出对象</h2><p>某些恶意软件使用Microsoft的服务器消息块（SMB）协议在基于Active Directory（AD）的网络中传播。早在2017年7月，一个名为Trickbot的银行木马就添加了蠕虫模块，该蠕虫模块使用基于EternalBlue的漏洞在SMB上跨网络传播。今天，我们仍在寻找该Trickbot蠕虫模块的迹象。</p>
<p>我们的下一个pcap代表Trickbot感染，该感染使用SMB从受感染的客户端10.6.26.110传播到其域控制器10.6.26.6.从pcap-example-03.pcap提取对象，在这里可用。在Wireshark中打开pcap。使用菜单路径File-&gt; Export Objects-&gt; SMB …，如图8所示。</p>
<p>![image-20210403170114367](/Users/yueting/Library/Application Support/typora-user-images/image-20210403170114367.png)</p>
<p>图9.进入“导出SMB对象”列表。</p>
<p>这将弹出一个Export SMB object列表，列出可以从pcap导出的SMB对象，如图9所示。</p>
<p>请注意列表中间附近的两个条目，其中 10.6.26.6  C $作为主机名。仔细检查它们各自的“文件名”字段，可以发现这是两个Windows可执行文件。有关详细信息，请参见下面的表1。</p>
<p>![image-20210403170157132](/Users/yueting/Library/Application Support/typora-user-images/image-20210403170157132.png)</p>
<p>在“内容类型”列中，我们需要[100.00％]导出这些文件的正确副本。小于100％的任何数字表示网络流量中有一些数据丢失，从而导致文件副本损坏或不完整。这些来自pcap的Trickbot相关文件具有SHA256文件哈希，如表2所示。</p>
<p>SHA256哈希文件大小<br>59896ae5f3edcb999243c7bfdc0b17eb7fe28f3a66259d797386ea470c010040 712 kB<br>cf99990bee6c378cbf56239b3cc88276eec348d82740f84e9d5c343751f82560 115 kB<br>表2. Windows可执行文件的SHA256文件哈希。</p>
<h2 id="从SMTP流量导出电子邮件"><a href="#从SMTP流量导出电子邮件" class="headerlink" title="从SMTP流量导出电子邮件"></a>从SMTP流量导出电子邮件</h2><p>某些类型的恶意软件旨在将受感染的Windows主机转变为垃圾邮件机器人。这些垃圾邮件发送器每分钟发送数百封垃圾邮件或恶意电子邮件。在某些情况下，邮件是使用未加密的SMTP发送的，我们可以从感染流量的pcap中导出这些邮件。</p>
<p>一个这样的示例来自我们的下一个pcap，即从pcap-example-04.pcap提取对象（在此处可用）。在此pcap中，受感染的Windows客户端发送垃圾邮件。在Wireshark中打开pcap，在smtp.data.fragment上进行过滤，您应该看到50个主题行示例，如图10所示。这是在来自一台受感染Windows主机的五秒钟的网络流量中发生的。</p>
<p>![image-20210403170339557](/Users/yueting/Library/Application Support/typora-user-images/image-20210403170339557.png)</p>
<p>图10.在Wireshark中过滤电子邮件发件人和主题行。</p>
<p>您可以使用菜单路径文件-&gt;导出对象-&gt; IMF …来导出这些消息，如图11所示。IMF代表Internet消息格式，它被保存为带有.eml文件扩展名的名称。</p>
<p>![](/Users/yueting/Library/Application Support/typora-user-images/image-20210403170403385.png)</p>
<p>在IMF对象列表中，所有色情短信垃圾邮件均以.eml文件扩展名列出，如图12所示。</p>
<p>导出这些.eml文件后，可以使用诸如Thunderbird之类的电子邮件客户端对其进行检查，也可以在文本编辑器中对其进行检查，如图13所示。</p>
<p>![image-20210403172937119](/Users/yueting/Library/Application Support/typora-user-images/image-20210403172937119.png)</p>
<p>图13.使用文本编辑器查看从pcap导出的.eml文件。</p>
<h2 id="4-从FTP流量导出文件"><a href="#4-从FTP流量导出文件" class="headerlink" title="4.从FTP流量导出文件"></a>4.从FTP流量导出文件</h2><p>一些恶意软件家族在恶意软件感染期间使用FTP。我们的下一个pcap具有从FTP服务器检索到的恶意软件可执行文件，然后将来自受感染Windows主机的信息发送回同一FTP服务器。</p>
<p>下一个pcap是从pcap-example-05.pcap提取对象，可在此处获取。在Wireshark中打开pcap。在ftp.request.command上进行过滤以查看FTP命令，如图14所示。您应该找到一个用户名（USER）和密码（PASS），然后是检索（RETR）五个Windows可执行文件的请求：q.exe, w.exe, e.exe, r.exe, and t.exe。随后是大约每1个将基于HTML日志文件（STOR）的请求存储回同一FTP服务器的请求。</p>
<p>ftp.request.command</p>
<p>![image-20210403173053072](/Users/yueting/Library/Application Support/typora-user-images/image-20210403173053072.png)</p>
<p>![image-20210403173229362](/Users/yueting/Library/Application Support/typora-user-images/image-20210403173229362.png)</p>
<p>TCP流 保存</p>
<p>![image-20210403173317980](/Users/yueting/Library/Application Support/typora-user-images/image-20210403173317980.png)</p>
<p>![image-20210403173430978](/Users/yueting/Library/Application Support/typora-user-images/image-20210403173430978.png)</p>
<ul>
<li>Filter on ftp-data</li>
<li>Follow the TCP stream for a TCP segment with the name of your file in the Info column</li>
<li>Change “Show and save data as” to “Raw”</li>
<li>Use the “Save as…” button to save the file</li>
<li>Check to make sure your saved file is, in fact, a Windows executable file.</li>
</ul>
<p>将从受感染的Windows主机发送的HTML文件导出回FTP服务器时，我们必须进行更精确的搜索。为什么？因为每次都使用相同的文件名。过滤ftp.request.command，然后滚动到末尾。我们可以看到与用于将窃取的数据（STOR）存储到FTP服务器（作为HTML文件）的文件名相同的文件名，如图20所示。</p>
<p>![image-20210403173710267](/Users/yueting/Library/Application Support/typora-user-images/image-20210403173710267.png)</p>
<p>图20.用于将窃取的信息发送回FTP服务器的相同文件名。</p>
<p>要查看通过ftp数据通道发送的关联文件，请使用过滤器ftp-data.command contains .html ，如图21所示。</p>
<p>![image-20210403173857536](/Users/yueting/Library/Application Support/typora-user-images/image-20210403173857536.png)</p>
<p>图21.通过FTP数据通道过滤文件名中带有.html的文件。</p>
<p>在图21中，每次将文件存储（STOR）到FTP服务器时，目标端口都会更改。第一次是TCP端口52202。第二次是TCP端口57791。第三次是TCP端口55045。第四次是57203。第五次是61099。</p>
<p>我们使用与以前相同的过程。与其关注文件名，不如关注TCP端口。使用端口52202跟随任何TCP段的TCP流。在TCP流窗口中，将“显示并将数据另存为”更改为“raw”。然后保存文件。对TCP端口57791上的HTML文件执行相同的操作。</p>
<p>如果对所有五个HTML文件都执行此操作，则会发现它们是完全相同的文件。这些基于文本的HTML文件包含有关受感染Windows主机的数据，包括由恶意软件找到的所有密码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/07/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB07-30/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ytytytytyt6.github.io/2020/07/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB07-30/" itemprop="url">demo.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-30T09:34:46+08:00">
                2020-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Automated Ransomware Behavior Analysis: Pattern Extraction and Early Detection Preprint</p>
<ol>
<li><h3 id="论文摘要"><a href="#论文摘要" class="headerlink" title="论文摘要"></a><strong>论文摘要</strong></h3><p>使用cuckoo sandbox分析得到的日志，三种机器学习方法（TF-IDF (term frequencyinverse document frequency), Fisher’s LDA (linear discriminant analysis) and ET (extra trees/extremely randomized trees)）实现了恶意代码模式提取和早期检测工具。可以实现三点：1.在沙箱环境中分析新发现的恶意代码样本并生成动态分析报告（主机日志）；2.自动提取与大数量未受攻击的主机日志相比恶意代码导致的事件序列，并且相关的少数日志从受到潜在多态恶意代码产生的；3.排列最具有辨识性的特征（独特模式）4.允许操作者可视化特征以及它们之间的关系用于取证。</p>
<p>整个实验数据：7个不同家族的勒索病毒WannaCry, DBGer, Cerber, Defray, GandCrab, Locky, and nRansom</p>
<p>实验结果：tf-idf最优，et时间效率 健壮</p>
</li>
<li><h3 id="论文结论"><a href="#论文结论" class="headerlink" title="论文结论"></a><strong>论文结论</strong></h3><p>![image-20200730100608003](/Users/yueting/Library/Application Support/typora-user-images/image-20200730100608003.png)</p>
</li>
<li><h3 id="论文贡献"><a href="#论文贡献" class="headerlink" title="论文贡献"></a><strong>论文贡献</strong></h3><p>1.使用cuckoo日志分析勒索病毒并且从主机行为报告中生成特征。</p>
<p>2.提取勒索病毒日志文件（大部分被感染和潜在来自未被感染的大量的ambient报告）产生的特征（事件序列）</p>
<p>3.排序最具有辨识性的特征并且去识别恶意代码行为在数据被勒索病毒加密之前。</p>
<p>4.创建图可视化et模型用于取证，便于操作者可视化独特模式及其关系。</p>
</li>
<li><h3 id="achievements"><a href="#achievements" class="headerlink" title="achievements"></a><strong>achievements</strong></h3><p>1。参考文献8 只考虑特征提取 tf-idf 一种勒索病毒</p>
<p>2.参考文献16 作者应用了序列模式挖掘用于找到最大频率模式msp 对于四种勒索病毒攻击，不同于本文中直接从主机文件中生成特征的方法，他们的方法总结了使用不同类型msp的行为。使用四种学习分类器，发现注册表的msp是最重要的序列在检测时可以达到99%。</p>
<p>3.27将主机日志文件嵌入到语义上有意义的度量空间，表示用于构建勒索病毒行为签名。用于提前检测。</p>
<p>4.28 REDFISH——一种勒索病毒检测算法，识别勒索病毒行为 当尝试加密共享文件的时候。基于被监视的smb流量分析，使用3个流量统计参数检测恶意行为。作者使用了19种勒索病毒家族测试该算法，均小于20秒。很高的检测率，但是不能在开始加密之前进行检测。</p>
<p>5.29全面的分析和调查</p>
<p>6.augment paths of specific files to emphasize their names only. For example, C:\Windows\system32\ \rsaenh.dll is converted to a string “c:..rsaenh.dll”.</p>
</li>
</ol>
<ol start="5">
<li><h3 id="启示和思考"><a href="#启示和思考" class="headerlink" title="启示和思考"></a><strong>启示和思考</strong></h3><p>1.主机日志是什么？Cuckoo analysis report (raw behavior log) </p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/ytytytytyt6.github.io/page/2/">2</a><a class="extend next" rel="next" href="/ytytytytyt6.github.io/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">万俟思睿</p>
              <p class="site-description motion-element" itemprop="description">进一寸有一寸的欢喜</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/ytytytytyt6.github.io/archives">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">万俟思睿</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/ytytytytyt6.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/ytytytytyt6.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/ytytytytyt6.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
