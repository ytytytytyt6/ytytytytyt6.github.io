<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/ytytytytyt6.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/ytytytytyt6.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/ytytytytyt6.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/ytytytytyt6.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/ytytytytyt6.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/ytytytytyt6.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/ytytytytyt6.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="12  漏洞相关概念** 1234熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）。通过关键字（栈溢出、堆溢出、整数溢出、UAF、double-free、shellcode）进行Google&#x2F;SecWiki等了解基本概念；阅读《Q版本缓冲区溢出》《0day漏洞挖掘》等书籍，学习二进制漏洞形成的基本原理和基本的利用方法，并进行实践操作；">
<meta property="og:type" content="article">
<meta property="og:title" content="漏洞基础概念">
<meta property="og:url" content="https://ytytytytyt6.github.io/2020/07/20/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/index.html">
<meta property="og:site_name" content="思睿&#39;s Blog">
<meta property="og:description" content="12  漏洞相关概念** 1234熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）。通过关键字（栈溢出、堆溢出、整数溢出、UAF、double-free、shellcode）进行Google&#x2F;SecWiki等了解基本概念；阅读《Q版本缓冲区溢出》《0day漏洞挖掘》等书籍，学习二进制漏洞形成的基本原理和基本的利用方法，并进行实践操作；">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590715345698.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590716744637.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590719859961.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590720390686.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590738829103.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739035362.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739080500.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739774369.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739931489.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739997458.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590740081376.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590740397359.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590801331139.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802080259.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802255755.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802478595.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802584284.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802993594.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590803269259.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590803348931.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590804022026.png">
<meta property="og:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590804829002.png">
<meta property="article:published_time" content="2020-07-20T05:10:56.000Z">
<meta property="article:modified_time" content="2020-05-30T02:31:02.000Z">
<meta property="article:author" content="万俟思睿">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590715345698.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/ytytytytyt6.github.io/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ytytytytyt6.github.io/2020/07/20/漏洞基础概念/"/>





  <title>漏洞基础概念 | 思睿's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/ytytytytyt6.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">思睿's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/ytytytytyt6.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ytytytytyt6.github.io/ytytytytyt6.github.io/2020/07/20/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="万俟思睿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ytytytytyt6.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="思睿's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">漏洞基础概念</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-20T13:10:56+08:00">
                2020-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>漏洞相关概念**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）。</span><br><span class="line">通过关键字（栈溢出、堆溢出、整数溢出、UAF、double-free、shellcode）进行Google&#x2F;SecWiki等了解基本概念；</span><br><span class="line">阅读《Q版本缓冲区溢出》《0day漏洞挖掘》等书籍，学习二进制漏洞形成的基本原理和基本的利用方法，并进行实践操作；</span><br><span class="line">学习《加密与解密》中部分章节，熟悉Windows系统的重要数据结构、函数传参方法以及PE文件结构等基础知识。</span><br></pre></td></tr></table></figure>

<h3 id="0x01-熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）"><a href="#0x01-熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）" class="headerlink" title="0x01 熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）"></a>0x01 熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）</h3><ol>
<li><p>二进制漏洞基本原理</p>
<p><a href="https://bbs.pediy.com/thread-252569.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-252569.htm</a></p>
<p>1）栈溢出漏洞原理 属于缓冲区漏洞</p>
<p>变量中的字符串通过strcpy拷贝到栈空间时，没有对字符串长度做限制，导致栈溢出，最后覆盖到了返回地址，造成程序崩溃。溢出后的栈空间布局如下</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590715345698.png" alt="1590715345698"></p>
<p>2）堆溢出漏洞原理</p>
<p>由于调试堆和常态堆结构不同，在演示代码中加入getchar函数，用于暂停进程，方便运行heapoverflowexe后用调试器附加进程。debug版本和release版本实际运行的进程中各个内存结构和分配过程也不同，因此测试的时候应该编译成release版本。</p>
<p>使用windbg函数附加调试，一定是附加调试</p>
<p>上面的ecx已经被AAAA字符串覆盖掉了，最后在应用改地址的时候导致崩溃，通过前面的栈回溯定位到了main函数入口，找到复制字符串的函数下断点</p>
<p>此时堆块已经分配完毕，对应的分配地址位于0x007104a0，0x007104a0是堆块数据的起始地址，并非堆头信息的起始地址，对已经分配的堆块，开头有8字节的HEAP_ENTRY结构，因此heap的该结构位于0x007104a0-8=0x710498。</p>
<p>在windbg上查看两个堆块的信息，目前处于占用状态，共有0x10大小空间（usersize） 查看命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">！heap -p -a 0x710498</span><br></pre></td></tr></table></figure>

<p>使用！heap查看HeapCreate创建的整个堆块信息，可以发现堆块后面还有一个0x007104c0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!heap</span><br><span class="line"></span><br><span class="line">!heap -a 710000</span><br></pre></td></tr></table></figure>

<p>在复制字符串时，原本只有0x10大小的堆块，填充过多字符串就会覆盖到下方空闲堆块007104c0，在复制前007104c0空闲堆块的HEAP_FREE_ENTRY结构数据如下：</p>
<p>dt _HEAP_FREE_ENTRY 0x007104c0</p>
<p>dt _LIST_ENTRY <code>0x007104c0</code>+8</p>
<p>覆盖之后的结果中出现？？整个空闲堆头信息都被覆盖了，包括最后的空闲链表中的前后向指针都变成了0x41414141，后面调用HeapFree释放堆块的时候，就会将buf2和后面的空闲堆块0x007104c0合并，修改两个空闲堆块的前后向指针就会引用0x41414141，最后造成崩溃。</p>
<p>如果把上面释放堆块的操作换成分配堆块HeapAlloc(),也会导致崩溃，因为在分配堆块时会遍历空闲链表指针，会造成地址引用异常，当内存中已经分配多个堆块时，可能覆盖到的就是已经分配的堆块，就可能覆盖HEAP_ENTRY结构，而不是HEAP_FREE_ENTRY结构。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590716744637.png" alt="1590716744637">3）堆调试技巧</p>
<p>微软提供，可以通过windbg提供的gflag.exe或者！gflg命令来设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">htc：堆尾检查，是否发生溢出</span><br><span class="line">hfc：堆释放检查</span><br><span class="line">hpc：堆参数检查</span><br><span class="line">hpa：启用页堆</span><br><span class="line">htg：堆标志</span><br><span class="line">ust：用户态栈回溯</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>对heapoverflow.exe添加堆尾检查和页堆，去掉堆标志：<strong>去掉堆标志为什么还是+htg？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;gflags.exe &#96;&#96;-&#96;&#96;i F:\vulns\Release\heapoverflow &#96;&#96;+&#96;&#96;htc &#96;&#96;+&#96;&#96;hpa &#96;&#96;+&#96;&#96;htg&#96;</span><br></pre></td></tr></table></figure>

<p>堆尾检查主要是在每个堆的尾部，用户数据之后添加8个字节，通常是连续的2个0xabababab，该数据段被破坏就可能发生了溢出。对heapoverflow.exe开启hpc和htc，用windbg加载对heapoverflow程序，附加进程无法在堆尾添加额外标志，使用以下命令开启堆尾检查和堆参数检查：</p>
<p>!gflag +htc +hpc</p>
<p>g</p>
<p>执行命令g后，回车程序会断下来</p>
<p>HEAP[heapoverflow.exe]: Heap block at 001E0498 modified at 001E04B0 past requested size of 10</p>
<p>调试输出信息是在大小为0x10的堆块001E0498 的001E04B0 覆盖破坏了，0x10大小的空间加上堆头的8字节一共0x18字节，0x001E04B0 -0x001E0498 =0x18，也即0x001E04B0 是位于堆块数据的最后一个字节上，基于上面信息，可以分析出程序主要是因为向0x10的堆块中复制过多数据导致的堆溢出。</p>
<p>页堆</p>
<p>在调试漏洞时，经常需要定位导致漏洞的代码和函数，比如导致堆溢出的字节复制指令rep movsz等，前面的堆尾检查方式主要是堆被破坏的场景，不利于定位导致漏洞的代码。为此引入页堆的概念，开启页堆，会在堆块中增加不可访问的栅栏页，溢出覆盖到栅栏页就会触发异常。</p>
<p>gflags.exe -i F:\vulns\Release\heapoverflow  +hpa</p>
<p>用windbg加载heapoverflow，运行上面命令开启页堆，然后g运行后cmd按下回车键断下。可以发现程序在复制A字符串时触发了异常，程序复制到0x11字节时被断下，此时异常还未破坏到堆块，知道定位导致溢出的复制指令rep movs<strong>[不是很能理解]</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; kb</span><br><span class="line">ChildEBP RetAddr  Args to Child             </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">0012ff48 00401327 00000001 01699fb0 0169bf70 image00400000+0x1084</span><br></pre></td></tr></table></figure>

<p>kb 根据栈回溯，调用rep movs的上一层函数位于image00400000+0x1084的上一条指令，也就是00401322，此处调用了00401000函数，很容易发现这是主入口函数：</p>
<p>uf 00401000</p>
<p>4）整数溢出漏洞原理</p>
<p>整数分为有符号和无符号两类，有符号以最高位作为符号位，正整数最高位为1，负整数最高位为0，不同类型的证书在内存中有不同的取值范围，unsigned int为4字节，int为4字节，当存储的数值超高该类型证书的最大值就会发生溢出。</p>
<p>在一些有符号和无符号转换过程中最有可能发生整数溢出漏洞。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用字节数</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>字符类型char</td>
<td>1</td>
<td>-128~127[2的8次方]</td>
</tr>
<tr>
<td>无符号字符类型unsigned  char</td>
<td>1</td>
<td>0~255</td>
</tr>
<tr>
<td>布尔类型 bool</td>
<td>1</td>
<td>0~1</td>
</tr>
<tr>
<td>短整型short</td>
<td>2</td>
<td>-32768~32767[2的16次方]</td>
</tr>
<tr>
<td>整型int</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>无符号整型unsigned int</td>
<td>4</td>
<td>0~4294967295</td>
</tr>
<tr>
<td>长整型long</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>无符号长整型unsigned long</td>
<td>4</td>
<td>0~4294967295[2的32次方]</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>1字节是8位</p>
<p><strong>基于栈的整数溢出</strong></p>
<p>代码中size变量是无符号短整型，取值范围为0-65535，输入值大于65535就会发生溢出，最后得到是size为4，这样会通过边界检查，但是使用memcpy复制数据的时候，使用的是int类型的参数i，这个值输入的是65540，就会发生栈溢出。</p>
<p><strong>基于堆的整数溢出</strong></p>
<p>代码中size变量是无符号短整型，取值范围为0-65535，当输入小于5时，size减去5会得到负数，但由于无符号短整型的取值范围限制无法识别负数，得到正数65535，最后分配得到过大的堆块，溢出覆盖了后面的堆管理结构。</p>
<p>5）格式化字符串漏洞原理</p>
<p>产生主要原因是对用户输入的内容没有做过滤，有些输入数据都是作为参数传递给某些执行格式化操作的函数的，比如printf，fprintf，vprintf，sprintf。</p>
<p>恶意用户可以使用%s和%x等格式符，从堆栈和其他内存位置输出数据，也可以使用格式符%n想任意地址写入数据，配合printf（）函数就可以向任意地址写入被格式化的字节数，可能导致任意代码执行，或者读取敏感数据。当输入数据包含%s和%x等格式符时，会议外输出其他数据，用ollydbg附加调试程序，执行前需要先设置命令行参数，调试-参数-命令行：test-%x</p>
<p>在运行程序后，传递给printf的参数只有test-%x，但他把输入参数test-%x之后的另一个栈上数据当做参数传给了printf函数，因为printf基本类型是printf（“格式化控制符”，变量列表）；</p>
<p>传递给printf参数只有一个，但是程序默认将栈上下一个数据作为参数传递给printf函数，刚好下一个数据是strcpy函数的目标地址，就是buff变量，buff刚好指向test-%x的地址0x0019fec4，所以程序会输出0x0019fec4，如果后面再加上%x就会将src参数值也输出了，这样就可以遍历整个栈上的数据了。</p>
<p>此外还可以使用%n写入数据修改返回地址来实现漏洞利用。</p>
<p>6）双重释放漏洞原理</p>
<p>Double Free漏洞是由于对同一块内存进行二次释放导致的，利用漏洞可以执行任意代码。在第二次释放p2时会发生程序崩溃，但是并不是每次出现Double Free都会发生崩溃，要有<strong>堆块合并动作</strong>发生才会发生崩溃。</p>
<p><strong><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590719859961.png" alt="1590719859961"></strong></p>
<p>在释放过程中，邻近的已经释放的堆块存在合并操作，这会改变原有堆头信息，之后再对其地址引用释放就会发生访问异常。</p>
<p>7）释放后重引用漏洞原理 UAF漏洞原理</p>
<p>buf2占了buf1的内存位置，经过UAF后，buf2被成功篡改</p>
<p>程序通过分配和buf1大小相同的堆块buf2实现占坑，buf2分配到已经释放的buf1内存位置，但是由于buf1指针仍然有效，并且指向的内存数据是不可预测的，可能被堆管理器回收，也可能被其他数据占用填充，buf1指针称为悬挂指针，借助悬挂指针buf1将内存赋值为hack，导致buf2也被篡改为hack。</p>
<p>如果原有漏洞程序引用到悬挂指针指向的数据用于执行指令，就会导致任意代码执行。在通常的浏览器UAF漏洞中，都是某个C++对象释放后重引用，假设程序存在UAF的漏洞，有个悬挂指针指向test对象，要实现漏洞利用，通过占坑的方式覆盖test对象虚表指针，虚表指针指向虚函数存放地址，现在让其指向恶意构造的shellcode，当程序再次引用到test对象就会导致任意代码执行。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590720390686.png" alt="1590720390686"></p>
<p>8）数组越界访问漏洞</p>
<p>数组访问越界漏洞包含读写类型，溢出属于数据写入</p>
<p>部分溢出漏洞本质是数组越界漏洞</p>
<p>前者像是倒水的时候倒错了杯子，溢出就像是水从杯子里溢出来</p>
<p>执行生成的程序，分别输入12345，当输入的数组下标为12的时候会得到正常数值，从索引3开始就超出了原来数组的范围。数组越界访问数组，导致读取不在程序控制范围内的数值。使用ollydbg调试发现array[5]就是从array开始的第六个数据0x4012A9，已经读取到了array之外的数据，如果越界访问距离过大，就会访问到不可访问的内存空间，导致程序崩溃。</p>
<p>9）类型混淆漏洞原理</p>
<p>类型混淆漏洞（Type Confusion）一般是将数据类型A当作数据类型B来解析引用，这就可能导致非法访问数据从而执行任意代码，比如将Unit转成了String，将类对象转成数据结构。</p>
<p>类型混淆型数据是现在浏览器漏洞挖掘的主流漏洞，这类漏洞在java，js等弱类型语言中非常常见。</p>
<p>以IE/Edge类型混淆漏洞（CVE-2017-0037）为例讲解，漏洞原因是函数处理时，没有对对象类型进行严格检查，导致类型混淆。</p>
<p>通过跟踪可以发现第一次调用Readable函数时ecx是一个正常的FlowItem对象，而第二次时是一个int Array Object。Layout::Patchable &gt;::Readable函数是处理虚表对象的函数，由于boom()函数中引用th1.align导致Readable函数得到第二次引用，由于没有进行对象属性检查，导致第二次调用时将table对象传入，最终发生类型混淆崩溃。</p>
<p>10）竞争条件漏洞原理</p>
<p>竞争条件（Race Condition）是由于多个线程/对象/进程同时操作同一资源，导致系统执行违背原有逻辑设定的行为，这类漏洞在linux，内核层面非常多见，在windows和web层面也存在。互斥锁的出现就是为了解决此类漏洞问题，保证某一对象在特定资源访问时其他对象不能操作此资源。</p>
<ol>
<li><p>漏洞类型</p>
<p>见第一部分</p>
</li>
<li><p>漏洞利用方法</p>
<p>漏洞分析方法<a href="https://www.cnblogs.com/freesec/p/6443870.html" target="_blank" rel="noopener">https://www.cnblogs.com/freesec/p/6443870.html</a></p>
<p>拿到poc分析漏洞成因关键步骤是定位到漏洞代码。</p>
<p><strong>栈溢出一般分析方法</strong></p>
<p>1基于字符串定位——当存在漏洞的代码片段引用了字符串时，IDA直接搜索，交叉引用，多处的话分别下断点看断在何处。</p>
<p>2基于栈回溯定位分析方法——当对字符串进行复制时溢出并向不可写的地方进行写入而发生异常，栈回溯并对返回地址上方进行反汇编，在这些call上下断点，可以断在漏洞代码附近。</p>
<p>基于污点追踪的漏洞分析方法——断在异常处代码时查看操作的寄存器值，向上追踪</p>
<p>针对activeX控件的分析方法——activeX控件注册到系统中后,在html中通过<object>标签的classid来引用, 在ie中对应的模块是oleaut32.dll, 函数是dispcallfunc.</p>
<p>在dispcallfunc函数中首个call ecx 即为activex中的被html调用的函数.可以直接在od中按 alt+e 找到模块,按ctrl+n找到函数. 然后找到call ecx跟进分析即可</p>
<p><strong>堆溢出一般分析方法:</strong></p>
<p>1.堆调试</p>
<p>!heap   查看程序用heapcreate函数创建的堆信息</p>
<p>!heap -p -a 地址    用于查看该地址的堆详细信息</p>
<p>dt _HEAP_FREE_ENTRY 地址      显示空闲堆块详细信息</p>
<p>dt _LIST_ENTRY　地址　　　　   显示系统链表结构信息</p>
<p>2.基于heapPage的分析方法</p>
<p>通过开启hpa后, 附加,加载poc,断下. 然后查看栈回溯,反汇编返回地址上方, 在上面找合适的地方下断点,重新运行调试断下,然后结合实际慢慢分析.</p>
<p>小技巧:当windows7这种系统有aslr时,直接对地址下断点可能有问题,所以可以直接用符号名代替,如bp mshtml!CTableLayout::CalculateMinMax</p>
<p>对上层函数下断:bp mshtml!CTableLayout::CalculateMinMax</p>
<p><strong>格式化字符串漏洞分析</strong></p>
<p>基于输出消息漏洞定位</p>
<p>其实就是一种字符串定位的方法</p>
<p>3.通过栈回溯和堆状态判断漏洞类型</p>
<p>4.基于ROP指令地址反向追踪</p>
</li>
</ol>
<ol>
<li><p>常见漏洞挖掘</p>
<p><a href="https://blog.csdn.net/stonesharp/article/details/50971701" target="_blank" rel="noopener">https://blog.csdn.net/stonesharp/article/details/50971701</a></p>
<p>二进制漏洞研究可以分为漏洞分析利用和漏洞挖掘两部分。漏洞挖掘方法较少。漏洞挖掘是一种注重结果不追求过程的工程。</p>
<p>1.手动法——不使用自动挖掘工具，手动进行分析，挖掘点是手动寻找的，畸形数据也是手动构造的。</p>
<p>优点：测试的主要是堆栈溢出漏洞，速度快，效率高。</p>
<p>缺点：文件格式漏洞难以挖掘</p>
<p>具体怎么挖掘：</p>
<p>1.确定挖掘点——凡是用户可控的数据点可以作为挖掘点。包括程序路径，输入消息，文件内配置消息等。</p>
<p>2.对挖掘点填充畸形数据——超长字符串，畸形字符，边界值数据等。超长字符串的效果更好，一般为堆栈溢出。</p>
<p>3.程序是否发生异常</p>
<p>4.分析——发生异常，用反汇编工具和汇编级调试器深入分析，找到异常原因，判断漏洞类型及危害。</p>
<h2 id="通用fuzz法进行漏洞挖掘："><a href="#通用fuzz法进行漏洞挖掘：" class="headerlink" title="通用fuzz法进行漏洞挖掘："></a><strong>通用fuzz法进行漏洞挖掘：</strong></h2><p>在不研究文件格式的情况下，用自动化测试工具对目标程序进行fuzz测试。</p>
<p>1.选取目标文件。<br>2.用我们的工具对目标文件的格式进行变异，生成大量的畸形样本。<br>3.让程序分别载入并解析这些畸形样本，监测程序是否会触发异常。<br>4.通过逆向分析这些异常样本，查看是否是漏洞同时确定危害级别。</p>
<p>评价一个通用fuzz工具的好坏，一般考虑以下两个方面<br>1.生成的样本是否足够畸形：只有样本足够畸形，才能保证覆盖面足够大，才能挖掘出更多的安全隐患。<br>2.监控功能是否足够的强大准确：通用fuzz的监控模块可以准确的监控到程序运行时所发生的异常。不误报，不漏报。</p>
</li>
</ol>
<h2 id="智能fuzz法进行漏洞挖掘"><a href="#智能fuzz法进行漏洞挖掘" class="headerlink" title="智能fuzz法进行漏洞挖掘"></a><strong>智能fuzz法进行漏洞挖掘</strong></h2><p>智能fuzz是对文件的结构进行分析，编写出表述文件结构的代码。然后fuzzer工具根据该代码的约束生成畸形样本，接下来就和通用fuzz相同了：执行畸形样本，监控异常。<br><strong>智能fuzz**</strong>的优点<strong>：执行效率高，效果好。可以挖掘其他方法挖掘不到的软件漏洞。<br>**智能fuzz缺点</strong>：需要深入研究相应的文件格式，并写出相应的文件格式脚本。该过程需要的时间较长。<br><strong>智能fuzz的步骤：</strong>1.研究要挖掘程序处理的相应文件格式，包括该格式的各种数据结构，约束规则等信息。<br>2.根据fuzzer规定的代码规则，编写相应规则的代码，来解析当前文件格式的结构。<br>3.用fuzzer工具通过我们写的代码，生成大量的畸形样本。<br>4.让fuzzer 执行并监控被挖掘程序处理畸形样本的运行情况，检测程序是否发生异常，如果异常保留异常样本和相关信息。<br>5.用OLLYDBG WINDBG IDA等工具深入分析崩溃信息，查看是否是漏洞同时确定危害级别。</p>
<p><a href="https://www.cesafe.com/html/3611.html常见漏洞挖掘思路：" target="_blank" rel="noopener">https://www.cesafe.com/html/3611.html常见漏洞挖掘思路：</a></p>
<p>前期信息收集</p>
<p>​    whois 站长之家 中国万网</p>
<p>​    社工库查询 尝试查询敏感信息</p>
<p>​    收集子域名，将其管理系统分开便于后期渗透 子域名扫描工具</p>
<p>​    github等代码托管工具 尝试获取敏感信息（数据库账号密码或者邮箱账号密码等）</p>
<p>web层漏洞挖掘</p>
<p>​    第一步获取得到的系统利用TOP500和自定义的密码字典爆破，尝试进入系统，进入以后，进行下一步漏洞挖掘——越权或SQL注入或任意文件上传；如果进入邮箱，把通讯录的人拔下来将其用户名加入TOP500爆破，其次查看是否具有一般邮箱的越权漏洞——越权查看他人邮件内容、任意密码修改、任意用户登录等，再利用社工库获得到的密码尝试进行登录，看是否成功或为管理员权限</p>
<p>挖掘子域名网站的SQL注入</p>
<p>挖掘逻辑漏洞 找一下修改地址 删除地址 尝试挖掘越权漏洞，如果存在可以支付的地方，可以尝试挖掘支付逻辑漏洞，一般把支付价格改为负数，如果有举报或反馈意见，可以尝试插一下</p>
<p>挖掘环境漏洞 看端口有么有配置环境啥的 tomcat有没有弱口令 有 getshell</p>
<p>扫描目录</p>
<p>挖掘APP层漏洞</p>
<p>很多app都是json传递数据的，json也是存在注入的，还有一些常见的漏洞——越权。sql注入，任意用户注册，任意用户密码重置，任意用户未授权登录，短信轰炸，拒绝服务等。如果想深入，可以学反编译，破解算法。</p>
<ol>
<li>shellcode编写</li>
</ol>
<p>shellcode是用来发送到服务器利用特定漏洞的代码，能在极小空间内完成一些基本且重要的工作。</p>
<p>编写方式3种：</p>
<p>1.直接编写16进制操作码，不现实</p>
<p>2.像C高级编写程序，编译后进行反汇编以获取汇编指令和十六进制操作码</p>
<p>3.编译汇编程序，将该程序汇编，从二进制中提取十六进制操作码</p>
<p>C语言编写注意事项：1.系统调用2.坏字符问题。shellcode一般是由十几或者几十个字节组成，这样的小程序如果要像linux服务程序一样引入头文件，导入符号表，调用系统函数，那么十几个字节根本就不能满足要求，因此需要利用系统最核心的调用机制，即通过软中断的方式获取需要的资源，以绕开系统调用。shellcode如果存储在堆或者栈的内存中，这样执行时就不能出现\x00这样的阶段字符，需要我们在构造shellcode时防止此类坏字符的出现。</p>
<p>提取shellcode</p>
<p>Int 0x80软中断调用</p>
<p>第一步，就是需要将系统调用号加入到eax中。</p>
<p>第二步，ebx用于保存函数调用的第一个参数（ecx存放第二个参数，edx存放第三个参数，esi存放第四个参数，edi存放第五个参数）</p>
<p>如果参数个数超过5个，那么就必须将参数数组存储在内存中，而且必须将该数组的地址存储在ebx中。</p>
<p>一旦加载寄存器之后，就会调用int 0x80 汇编指令来发出软中断，强迫内核暂停手头上的工作并处理该中断。</p>
<h4 id="验证int-0x80-调用"><a href="#验证int-0x80-调用" class="headerlink" title="验证int 0x80 调用"></a>验证int 0x80 调用</h4><h3 id="编写汇编源码"><a href="#编写汇编源码" class="headerlink" title="编写汇编源码"></a>编写汇编源码</h3><p>一般来说shellcode的总长度都非常短，所以可以直接采用汇编形式编写，这样不但可以直接通过软中断形式执行系统调用，而且可以控制坏字符的出现。如下图所示，为一个返回汇编行的shellcode代码</p>
<p>通过Metaspolit的shellcode自动生成工具可以自动生成各种功能shellcode，为快速利用漏洞攻击系统提供更便捷方式。但是如果想自己想学习shellcode的编写过程还是需要亲身试验，亲自操作，才能发现问题，解决问题。</p>
<p><a href="https://www.cnblogs.com/binarysystemloophole/articles/10576310.html" target="_blank" rel="noopener">https://www.cnblogs.com/binarysystemloophole/articles/10576310.html</a> Shellcode编写 定位API内容</p>
<p>加密与解密解压码<a href="http://www.sanye.cx" target="_blank" rel="noopener">www.sanye.cx</a></p>
<p>Q版缓冲区溢出教程笔记</p>
<p>第一章、Windows 下堆栈溢出入门</p>
<p>现在最流行的有攻击手段两种方式，一种是SQL注入，另一种就是缓冲 区溢出攻击。</p>
<p>在计算机内部，输入数据通常被存放在一个临时空间内， 这个临时存放空间就被称为缓冲区，缓冲区的长度事先已经被程序或者操作系统定义好了。缓冲区就很像那个 啤酒杯，用来装东西，而且大小固定。”“向缓冲区内填充数据，如果数据的长度很长（如同那瓶啤酒），超过了缓冲区（那个啤酒杯）本身的容量， 那么结果就如同啤酒一样，四处溢出，数据也会溢出存储空间！装不下的啤酒会流到桌子上，而装不下的数据 则会覆盖在合法数据上，这就是缓冲区和缓冲区溢出的道理。”</p>
<p>先把缓存区溢出利用理解为允许攻击者往某个程序变量中放一个比期望长 度要长的值，由此以当前运行该程序的用户的特权执行任意命令。</p>
<p>关键——Windows 系统内部处理缓冲区的机制，我们明白了这个之后，就可利用缓冲区溢出漏洞来控制别人的主 机。</p>
<p>strcpy（des，source） 不检查拷贝的长度，它会一直拷贝，直到source结尾，即是strcpy的弱点。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590738829103.png" alt="1590738829103"></p>
<p>Windows的运行机制——中断和堆栈</p>
<p>中断及其处理过程</p>
<p>堆栈——计算机为了能回头处理原来的事情，需要把原来指令的指针EIP保存在堆栈中； 当要回去原来的地方时，就把保存在堆栈中的EIP恢复即可。并且各个函数的局部变量的分配也是在堆栈中。堆栈是一种数据结构，遵循“先进后出，后进先出”的规则，存取的动作就是PUSH和POP。windows下堆栈的分配是高地址往低地址分配的。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739035362.png" alt="1590739035362"></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739080500.png" alt="1590739080500"></p>
<p>因此可以通过覆盖EIP为任意值让程序运行到一个错误的地方。——想要的程序shellcode——实现任意功能的代码</p>
<p>Shellcode编写</p>
<p><em>Windows不像Unix那样使用系统调用来实现关键函数。Windows通过动态链接库来提供系统函数，就是 所谓的Dll。</em></p>
<p>程序变成机器码——在VC中按F10调试，在Debug工具栏中点击最后一个Disassemble，出现源程序的汇编代码，然后在代码窗口点击鼠标右键，弹出菜单选择Code Bytes。</p>
<p>需要做一些相关工作才可以直接抄取机器码，shellcode会在后面讲到。</p>
<p>本地缓冲区溢出简单利用</p>
<p>缓冲区溢出的基本原理和精髓——1.返回点定位：知道有问题程序返回的精确位置，2shellcode编写：有shellcode，3把有问题程序返回点地址覆盖成shellcode的地址。关于第三部，1999年天才想法——：用系统核心dll里的指令来完成跳转！</p>
<p><em>过去Unix的覆盖方法：</em></p>
<p><em>1.NNNNNNNNNSSSSSSSSSSSRRRRRRRRRRRRRR型。适合于大缓冲区，“N”代表空指令，也就是0x90，在实际运行 中，程序将什么也不做，而是一直延着这些NOPS运行下去，直到遇到不是NOPS的指令再执行之；“S”代表ShellCode；“R”代表覆盖的返回地址，思路是把返回地址R覆盖为nops的大概位置，这样就会跳到Nop中， 然后继续执行，直到我们的ShellCode中。但这种方法由于定位不准确，所以使用起来也不准确。</em><br><em>2.RRRRRRRRRRNNNNNNNNNNNSSSSSSSSSS型。 是用大量的“R” 填满整个缓冲区， 然后大量的Nop， 最后是ShellCode。 这里，“R”往后跳到Nop中，再顺着往下执行就会到ShellCode中。但在Windows下，“R”中必定会含有0， 这样，整个构造就会被截断，只能用于Unix中。</em><br><em>Windows的系统核心dll包括kernel32.dll、user32.dll、gdi32.dll。这些dll一直位于内存中，而且对应 于固定的版本，Windows加载的位置是固定的。</em></p>
<p>在Windows下如何利用系统核心dll里的指令来完成跳转？用系统核心dll 中的jmp esp地址来覆盖返回地址，而把ShellCode紧跟在后面，这样就可跳转到我们的ShellCode 中。其利 用格式是 NNNNNNRSSSSSS，N＝Nop， S＝ShellCode， R＝jmp esp的地址 </p>
<p>理解关键——覆盖后的缓冲区如图，N表示NOP，存原EIP的地方覆盖成了JMP ESP地址，接下去的S0,S1等表示Shellcode开始的0字节，1字节等。函数执行完毕，要返回时堆栈指针ESP会指向保存原EIP的地方，而指令指针EIP指向Ret指令。 </p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739774369.png" alt="1590739774369"></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739931489.png" alt="1590739931489"></p>
<p>Ret相当于 Pop EIP ，就是把栈顶指针ESP指向的值弹出来给EIP。所以在正常情况下，Ret执行后，就可 把原来的EIP恢复，从而回到中断前的流程。</p>
<p>但保存的EIP已经被我们覆盖成JMP ESP指令的地址了。这样执行 Pop EIP 后，EIP会被改为JMP ESP 的地址，即指向JMP ESP。而堆栈指针ESP往下移一位，指向ShellCode的第一个字节。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590739997458.png" alt="1590739997458"></p>
<p>计算机会往下继续执行EIP指向的指令——JMP ESP ,而ESP指向的是S0，这样就JMP 到了S0中，开始执行shellcode了。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590740081376.png" alt="1590740081376"></p>
<p><em>EIP指令指针指向下一条要执行的命令，一般会自动加1。ESP堆栈顶指针指向堆栈的顶部。在PUSH 时，ESP往上走，减1；在POP时，ESP往下走，加1。</em></p>
<p>JMP ESP ——FF E4机器码 ——0x77e0492b（windows 2000 sp2）</p>
<p>程序返回时，执行Ret=POP EIP ，EIP就会变成0x77e0492b，而ESP往下走，指向Shellcode第一个字节中。系统执行EIP指向的指令，跳转ESP，而此时ESP指向的是Shellcode的第一个字节，正好进入到我们的Shellcode中。</p>
<p>这里JMP ESP的地址，会由于版本的不同而不一样。比如在Win2000 的User32.dll 中，JMP ESP指令的地址分别为： <em>sp0:0x77e2e32a、 sp1:0x77e8898b、 sp2:0x77e0492b、 sp3:0x77e188a7、 sp4:0x77e22c75。</em> 以前很多攻击利用程序需要带上对方版本的参数。<strong>后来发现了可以通用的地址。</strong>是什么？</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590740397359.png" alt="1590740397359"></p>
<p>小结：缓冲区溢出编程的基本原理和步骤，对一个有漏洞的程序通过精心构造数据，改变程序流程弹出了一个Dos窗口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">​	LoadLibrary(<span class="string">"msvcrt.dll"</span>);</span><br><span class="line">​	system(<span class="string">"command.com"</span>);</span><br><span class="line">​	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Windows漏洞的缓冲区溢出利用编写</p>
<p>Foxmail溢出漏洞编写</p>
<p><em>FoxMail是国内著名的Internet电子邮件客户端软件。可以到其主页<a href="http://www.FoxMail.com.cn获得最新的信息" target="_blank" rel="noopener">www.FoxMail.com.cn获得最新的信息</a></em></p>
<p>分析漏洞公告</p>
<p>拿到公告之后——什么程序，什么版本有漏洞</p>
<p>Win2000 SP2+FoxMail5.0 beta1</p>
<p>除此之外，公告一般还会给出漏洞的解决办法或补丁下载。当然漏洞公告不会告诉如何利用漏洞的，所以除了查看楼顶公告，还要查找其他人或安全组织的相关漏洞分析报告。比如root关于FoxMail漏洞的分析</p>
<p>如何写出该缓冲区溢出的利用程序呢？</p>
<p>1.有问题程序返回点的精确位置――我们可以把它覆盖成任意地址。漏洞公告和漏洞分析——From字段太长就会覆盖到返回地址，程序很简单，往邮箱发送一封信，只有“From：字段”，对该字段进行填充，不能超过0x200长度，因此先填充0x150个A</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590801331139.png" alt="1590801331139"></p>
<p><em>*小知识：不同出错处理的外在表现</em><br>1.弹出“只有一个确定按钮的红叉框”，意味着外层有“<strong>try/</strong>except”块决定处理异常，而内层有“__ try/<strong>finally”块。当按下确定后，是在“</strong>try/<strong>finally”中执行。 2.弹出“有调试、关闭按钮的非红叉框”，意味着设置了“Just-In-Time Debugging”，并获得机会执行，这 已经是最后机会了。 3.弹出“只有一个关闭按钮的非红叉框”，意味着没有设置“Just-In-Time Debugging”，内层也没有决定处 理异常的“</strong>try/<strong>except”块。 4.触发异常，但什么框也未弹出，意味着内层有“</strong>try/__except”块决定处理异常。或者在异常处理过程中 再次触发异常。* </p>
<p>一个不能读，一个不能写——改进——采用二分法 0x150太长，换成0x75,0x75没有报错，试一下0x115，覆盖到0x104时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span> (<span class="built_in">buffer</span>, <span class="number">0x41</span>, <span class="number">0x104</span>);</span><br><span class="line"><span class="built_in">sprintf</span> (temp, <span class="string">"From: %s\r\n"</span>, <span class="built_in">buffer</span>); </span><br><span class="line">send (sock, temp, <span class="built_in">strlen</span> (temp), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=<span class="number">0x104</span>; i++) </span><br><span class="line">	<span class="built_in">buffer</span>[i] = <span class="string">'A'</span> + i % <span class="number">10</span>; </span><br><span class="line"><span class="built_in">sprintf</span> (temp, <span class="string">"From: %s\r\n"</span>, <span class="built_in">buffer</span>); </span><br><span class="line">send (sock, temp, <span class="built_in">strlen</span> (temp), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=<span class="number">0x104</span>; i++) </span><br><span class="line"><span class="built_in">buffer</span>[i] = <span class="string">'A'</span> + i / <span class="number">10</span>; </span><br><span class="line"><span class="built_in">sprintf</span> (temp, <span class="string">"From: %s\r\n"</span>, <span class="built_in">buffer</span>);</span><br></pre></td></tr></table></figure>

<p>分析：第一次使用2.c,是在‘From:’字段不停的加上A<del>J的循环（就是十六进制0x41</del>0x4A 这十个数的循 环）<strong>报错最小值为0x47</strong>。第二次用FoxMail3.c，是以10为一段长度，每段分别为0x41、0x42……来填充‘From:’<strong>报错为0x5A</strong></p>
<p>（0x5A－0x41）×10＋（0x47－0x41）＝25×10 ＋6＝256</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="string">'A'</span>, <span class="number">0x104</span>); </span><br><span class="line"><span class="built_in">buffer</span>[<span class="number">256</span>] = <span class="string">'B'</span>; </span><br><span class="line"><span class="built_in">buffer</span>[<span class="number">257</span>] = <span class="string">'B'</span>; </span><br><span class="line"><span class="built_in">buffer</span>[<span class="number">258</span>] = <span class="string">'B'</span>;</span><br><span class="line"><span class="built_in">buffer</span>[<span class="number">259</span>] = <span class="string">'B'</span>;</span><br></pre></td></tr></table></figure>

<p>指定‘From:’字段第256开始的四个字节是‘BBBB’，进行验证。在标准的堆栈溢出中，可以经常使用该方法进行定位。</p>
<p>2.ShellCode――一个提供给我们想要的功能的代码。 </p>
<p>就直接给出在中文Win2000 SP2下添加名为‘w’用户的 ShellCode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ShellCode[] = <span class="string">"\x8B\xE5\x55\x8B\xEC\x33\xFF\x57\x57\x57\x57\xC7\x45\xF1\x6E\x65"</span> <span class="string">"\x74\x20\xC7\x45\xF5\x75\x73\x65\x72\xC7\x45\xF9\x20\x77\x20\x2E"</span> <span class="string">"\x80\x45\xFC\x01\xC6\x45\xFD\x61\xC6\x45\xFE\x64\x33\xC0\x88\x45"</span> <span class="string">"\xFF\x8D\x45\xF1\x50\xB8\x4A\x9B\x01\x78\xFF\xD0"</span> ;</span><br></pre></td></tr></table></figure>

<p>3.JMP ESP的地址――把返回点覆盖JMP ESP 的地址，这样可跳入ShellCode</p>
<blockquote>
<p>中文版Win2000、 XP、Win2003的JMP ESP 通用跳转地址（lion给出的0x7ffa4512）</p>
</blockquote>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802080259.png" alt="1590802080259"></p>
<p>这样和最开始覆盖0x150个A测试时是类似的，Shellcode会把程序要写的参量覆盖，程序在返回之前会产生write类型错误！——①注意覆盖参量为可写的地址，即保证参量是可写的，不让他出现write错误，但是这种需要知道不能写的参量的所有位置；②覆盖异常，③Shellcode放在前面，不覆盖参量。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802255755.png" alt="1590802255755"></p>
<p>总结：</p>
<blockquote>
<p>第一步、精确定位返回点。我们用求余取整法可巧妙得到返回位置。</p>
<p>第二步、ShellCode编写。我们直接用别人写好的ShellCode。</p>
<p>第三步、JMP ESP的地址。我们使用Lion共享的中文通用地址――0x7ffa4512。</p>
<p>最后把它们合起来，由于返回点后面不远处不能覆盖，所以我们把组合位置作稍稍改变，把ShellCode放前 面，RET后面放一个往前跳的指令，用这样的方式跳到我们的ShellCode中。</p>
</blockquote>
<p>IIS5.0 Printer漏洞。Win2000SP0、SP1版本</p>
<p>微软Win2K IIS5的打印ISAPI扩展接口建立了.printer扩展名到msw3prt.dll的映射关系，缺省情况下该 映射存在。当远程用户提交对.printer的URL请求时， IIS5调用msw3prt.dll解释该请求。由于msw3prt.dll 缺乏足够的缓冲区边界检查，远程用户可提交一个精心构造的针对.printer的URL 请求，这样，就会在 msw3prt.dll中发生典型的缓冲区溢出，潜在允许执行任意代码。——漏洞的背景和原因。</p>
<p>http://域填充到268 个字节时就可以覆盖到EIP。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802478595.png" alt="1590802478595"></p>
<p>另一种溢出方式——JMP /CALL EBX——覆盖异常处理地址</p>
<p><strong>Windows 异常处理链表</strong></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802584284.png" alt="1590802584284"></p>
<p>当系统遇到一个不知道如何处理的程序时，就会查找对应的异常处理程序，并将处理程序的地址赋给EIP，这样系统就会执行处理程序以避免系统崩溃。最后一个处理程序就是弹出对话框报错。<strong>异常处理也有很深的技术原理</strong></p>
<p>Windows 2000系统的知识——就是在判断是否使用现在指向的异常处理程序时，<strong>EBX会自动变为下一处理点的地址</strong>，这 样可以把异常处理地址连接起来，形成一个异常处理串</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590802993594.png" alt="1590802993594"></p>
<p>故意把返回地址覆盖成一个错误的地址，出错时windows就会跳到处理错误的入口点，而EBX就在入口前4个字节的地方。JMP 04往后跳四个字节。将错误入口覆盖为JMP EBX的地址，就会跳过覆盖值，到达我们的shellcode。接管异常。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590803269259.png" alt="1590803269259"></p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590803348931.png" alt="1590803348931"></p>
<p>这里的A有多少呢？——不知道异常处理入口点在哪里呢？牛人的做法——用工具Attach 有问题的服务，然后反汇编、跟踪进去。找到有问题的点，就向上找到该服务的异常处理入口。直接分析出异 常处理入口位置距离溢出点的长度。菜鸟——比较简单，相对于直接分析服务，将JMP ESP方式改写为JMP EBX。</p>
<blockquote>
<p>其思路是：先利用JMP ESP的攻击程序在JMP ESP代码后跟上“\xeb\xfe”，这句 即JMP –1。实行模拟攻击后，在被攻击机上调出SoftICE，就会发现停在“\xeb\xfe”这句。这时，我们查 看其fs:0000的值，它里面存的就是异常处理的入口地址！这时，我们计算那个值离现在的距离，就能轻松知 道要填充多少才能达到异常处理入口了。</p>
</blockquote>
<blockquote>
<p>SoftICE<br>动态分析中最重要的是调试器，分为用户模式和内核模式两种类型。用户模式是指用来调试用户模式的应用程 序，它们工作在Ring 3级，如Visual C++等编译器自带的调试器。内核模式调试器指能调试操作系统内核的 调试器，它们处于CPU和操作系统之间，工作在Ring 0 级，如SoftICE。<strong>SoftICE 是Compuwar NuMega公司 的产品，是目前公认的最好的系统级调试工具！</strong>兼容性和稳定性极好，可在源代码级调试各种应用程序和设备 驱动程序，也可使用RCP/IP连接进行远程调试。</p>
</blockquote>
<p>softice没有单独版本，都是和numega的driverstudio一起发布的</p>
<p>Ctrl+D呼出</p>
<p>什么时候RET RET 04</p>
<blockquote>
<p>Windows下存在两种调用方式：C 式和Pascal式。第一种是C方式，这是C 和C++的缺省调用方式，函数修饰为<em>cdecl。它由主调用进行参数压栈并且恢复堆 栈，这样被调用函数就只用执行RET返回就行了。第二种是Pascal 方式，大多数Windows API 函数使用这种方式，函数修饰为WINAPI、 PASCAL、 CALLBACK或</em> stdcall。这种方式是由主调用负责压栈，而在被调用函数中恢复堆栈，返回就需要执行RET n了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data</span><br><span class="line">dd FS:0 &#x2F;&#x2F;显示值 可以看到0038:00000000 00D8F428</span><br></pre></td></tr></table></figure>

<p>00D8F428就是这里的异常入口地址。如果出现异常错误，EBX就会变为0x00D8F428, 而系统会跳到 0x00D8F428+4 = 0x0172f42c中执行处理代码。把0x00D8F42C 覆盖成JMP EBX的地址，而把0x00D8F428覆盖成NOP NOP JMP 04 指令</p>
<p>计算——覆盖的返回点0x00D8F3D8，异常点在0x00D8F428，异常点比覆盖返回点多80个字节。</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590804022026.png" alt="1590804022026"></p>
<blockquote>
<p>小知识：SoftICE的常用指令<br>SoftICE指令比较多，功能也比较强。在调试和破解时，常用的指令有：<br>F10：单步执行，CALL, INT会被跳过；<br>F8：单步执行，CALL, INT会被切入；<br>Ctrl＋上下键或ALT＋上下键：在数据窗口或代码窗口中移动。在鼠标失灵时特别有用。<br>BPX：设置执行地址断点，格式为 BPX 地址 和 BPX 函数名 。这个函数名可以是任意一个Windows API函 数，是破解时的明星指令。<br>U：反汇编，格式为 U 地址 。可以看到该地址后的指令代码是什么，测试Exploit时经常用来查看ShellCode 的功能。<br>D：查看内存数据。经常用来对照比较ShellCode 是否被改变。<br>R：更改寄存器的值。格式为 R 寄存器名=值 ，当EIP 陷入死循环时，又不想重启机器，就用R 来改变EIP 的值，手动跳出死循环。</p>
</blockquote>
<p>总结：</p>
<p>JMP/CALL EBX 方式的利用格式是 NNNNNJESSSSSS 。这里，N=NOP，J=JMP 04，E =JMP EBX的地址， S=ShellCode。这样异常处理时，就会执行JMP EBX，而EBX 在 J的位置，那就可以跳过E， 进入ShellCode了。</p>
<p>JMP ESP CALL EBX都可以用，特定情况只能使用一种——如果程序还是有长度限制不能覆盖到异常处理点，但 可以覆盖到返回地址时，那就只能用JMP ESP覆盖EIP； CALL EBX当能覆盖异常处理点时（在返回前就有异常）。另外，在XP 下发生异常时，EBX不再指向下一处理链表，而改成了堆栈中的第三个值指向下一处理链表。所 以，要使用pop pop ret 在内存中的地址覆盖异常处理点，而通用地址就是0x7ffa1571。</p>
<p>IIS 的IDA/IDQ漏洞</p>
<blockquote>
<p>作为安装IIS过程的一部分，系统还会安装几个ISAPI扩展.dll，其中，idq.dll 是Index Server 的一个组 件，对管理员脚本和Internet数据查询提供支持。但是，idq.dll 在一段处理URL输入的代码中存在一个未 经检查的缓冲区，攻击者利用此漏洞能导致受影响的服务器产生缓冲区溢出，从而执行自己提供的代码。更为 严重的是，idq.dll是以System身份运行的，攻击者可以利用此漏洞取得系统管理员权限。该漏洞对Win2000 SP0、SP1、SP2有效。大家可以看到，采用 GET /NULL.ida?[bufer]=x HTTP /1.1 对 Buffeer（缓冲区）域进行填充，就可以覆盖到EIP，再继续也可以覆盖到异常处理点。</p>
</blockquote>
<p>三步：异常处理点位置（缓冲区）第240字节处，因此在236字节处放上NOP NOP jmp 04，在240字节处放上JMP EBX地址，在244字节处放上shellcode。shellcode添加用户。jmp ebx——0x7ffa1571</p>
<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590804829002.png" alt="1590804829002"></p>
<p>宽字符——双字节、多语言字符代码。unicode——在shellcode前面加上%u符号。</p>
<p>课堂解惑</p>
<p>1.无需知道ESP值。0x7FFA4512.JMP ESP指令（机器码为FF E4_VC中可以用“__asm{}”嵌入汇编JMP ESP，再按F10进入调试）的地址在同种系统甚至不同系统都是0x7FFA4512。</p>
<p>2.覆盖异常处理点时，我用的就是CALL EBX指令地址，失败——xp系统EBX会变成0，需要用POP POP RET指令地址来覆盖。个中文版ＮＴ/Win2000/Win2003都通用的地址——0x7FFA1571。</p>
<p>3.linux确切定位shellcode——把shellcode放在环境变量</p>
<p>第二章 windows下shellcode编写初步</p>
<p>ShellCode是一组能完成我们想要的功能的机器代码，通常以十六进制数组的形式存在。计算机能直接执行的机器代码，只要计算机的指令指针EIP指向shellcode里面，就可以顺利执行了。</p>
<blockquote>
<p>计算机每次都只是执行当前EIP指向的指令（单CPU）。在当前指令执行后，EIP 会自动加1，从而指向下一 条指令。如果有JMP CALL RET一类的指令，EIP就会被强行改变成指定的地址，从而完成流程的跳转。</p>
</blockquote>
<p>像在Debug时动态改变寄存器值一样</p>
<p>最好能开一个DOS窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    LoadLibrary(“msvcrt.dll”);</span><br><span class="line">    system(“command.com”);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt; #include &lt;winbase.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR)</span></span>; <span class="comment">//定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    HINSTANCE LibHandle; </span><br><span class="line">    MYPROC ProcAdd; </span><br><span class="line">    LibHandle = LoadLibrary(“msvcrt.dll”); </span><br><span class="line">    ProcAdd = (MYPROC) GetProcAddress(LibHandle, <span class="string">"system"</span>); <span class="comment">//查找system函数地址 </span></span><br><span class="line">    (ProcAdd) (<span class="string">"command.com"</span>); <span class="comment">//其实就是执行system(“command.com”)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义函数指针，指向函数的参数是字符串，返回值是空。该指针的作用是指向system函数，然后在后面方便调用；</p>
<p>加载msvcrt.dll这个动态链接库，动态链接库的句柄赋给LibHandle。获得句柄后，我们再使用GetProcAddress获得system的真实地址，使用真实地址调用system函数。执行该语句后，ProcAdd为指向system函数的指针。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/ytytytytyt6.github.io/2020/05/28/%E2%80%9C%E6%BC%8F%E6%B4%9E%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E2%80%9D/" rel="next" title="“漏洞样本分析”">
                <i class="fa fa-chevron-left"></i> “漏洞样本分析”
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/ytytytytyt6.github.io/2020/07/20/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/" rel="prev" title="漏洞笔记">
                漏洞笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">万俟思睿</p>
              <p class="site-description motion-element" itemprop="description">进一寸有一寸的欢喜</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/ytytytytyt6.github.io/archives">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x01-熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）"><span class="nav-number">1.</span> <span class="nav-text">0x01 熟悉基本概念和原理（二进制漏洞基本原理、漏洞类型、漏洞利用方法、常见漏洞挖掘、shellcode编写）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通用fuzz法进行漏洞挖掘："><span class="nav-number"></span> <span class="nav-text">通用fuzz法进行漏洞挖掘：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#智能fuzz法进行漏洞挖掘"><span class="nav-number"></span> <span class="nav-text">智能fuzz法进行漏洞挖掘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#验证int-0x80-调用"><span class="nav-number">0.1.</span> <span class="nav-text">验证int 0x80 调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写汇编源码"><span class="nav-number">1.</span> <span class="nav-text">编写汇编源码</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">万俟思睿</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ytytytytyt6.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/ytytytytyt6.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/ytytytytyt6.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/ytytytytyt6.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/ytytytytyt6.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/ytytytytyt6.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
